"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = exports.sign = exports.writeIncompleteTransaction = exports.writeTransaction = exports.serializedSize = exports.estimateTransactionSize = void 0;
const bsv = require("./bsv");
const digest32_1 = require("./fields/digest32");
const int32Little_1 = require("./fields/int32Little");
const uint32Little_1 = require("./fields/uint32Little");
function varIntSize(n) {
    if (n < 253)
        return 1;
    if (n < 0x10000)
        return 3;
    if (n < 0x100000000)
        return 5;
    return 9;
}
// (step 2) given an incomplete transaction, we determine the expected size here.
// this is used to determine the fee.
function estimateTransactionSize(x) {
    let size = 8 + varIntSize(x.outputs.length) + varIntSize(x.inputs.length);
    for (let input of x.inputs)
        size += 40 + varIntSize(input.scriptSize) + input.scriptSize;
    for (let output of x.outputs)
        size += 8 + varIntSize(output.script.length) + output.script.length;
    return size;
}
exports.estimateTransactionSize = estimateTransactionSize;
function serializedSize(x) {
    let size = 8 + varIntSize(x.outputs.length) + varIntSize(x.inputs.length);
    for (let input of x.inputs)
        size += 40 + varIntSize(input.script.length) + input.script.length;
    for (let output of x.outputs)
        size += 8 + varIntSize(output.script.length) + output.script.length;
    return size;
}
exports.serializedSize = serializedSize;
class Writer {
    constructor(size) {
        this.position = 0;
        this.buf = Buffer.alloc(Number(size));
    }
    write_buffer(b) {
        b.copy(this.buf, this.position);
        this.position += b.length;
    }
    write_var_int(n) {
        var buf;
        if (n < 253) {
            buf = Buffer.alloc(1);
            buf.writeUInt8(n, 0);
        }
        else if (n < 0x10000) {
            buf = Buffer.alloc(1 + 2);
            buf.writeUInt8(253, 0);
            buf.writeUInt16LE(n, 1);
        }
        else if (n < 0x100000000) {
            buf = Buffer.alloc(1 + 4);
            buf.writeUInt8(254, 0);
            buf.writeUInt32LE(n, 1);
        }
        else {
            buf = Buffer.alloc(1 + 8);
            buf.writeUInt8(255, 0);
            buf.writeInt32LE(n & -1, 1);
            buf.writeUInt32LE(Math.floor(n / 0x100000000), 5);
        }
        this.write_buffer(buf);
    }
    write_input(i) {
        this.write_buffer(i.prevTxId instanceof Buffer ?
            i.prevTxId : (i.prevTxId instanceof digest32_1.Digest32 ?
            i.prevTxId : digest32_1.Digest32.fromHex(i.prevTxId)).buffer);
        this.write_buffer((i.outputIndex instanceof uint32Little_1.UInt32Little ?
            i.outputIndex : uint32Little_1.UInt32Little.fromNumber(i.outputIndex)).buffer);
        let script = i.script instanceof Buffer ? i.script : Buffer.from(i.script, 'hex');
        this.write_var_int(script.length);
        this.write_buffer(script);
        this.write_buffer((i.outputIndex instanceof uint32Little_1.UInt32Little ?
            i.outputIndex : uint32Little_1.UInt32Little.fromNumber((!i.outputIndex) ?
            0xffffffff : i.outputIndex)).buffer);
    }
    write_satoshis(n) {
        this.write_buffer(bsv.crypto.BN.fromNumber(n).toBuffer({ size: 8 }).reverse());
    }
    write_output(o) {
        this.write_satoshis(o.satoshis);
        let script = o.script instanceof Buffer ? o.script : Buffer.from(o.script, 'hex');
        this.write_var_int(script.length);
        this.write_buffer(script);
    }
    write_transaction(tx) {
        this.write_buffer((tx.version instanceof int32Little_1.Int32Little ?
            tx.version : uint32Little_1.UInt32Little.fromNumber(tx.version)).buffer);
        this.write_var_int(tx.inputs.length);
        for (let input of tx.inputs)
            this.write_input(input);
        this.write_var_int(tx.outputs.length);
        for (let output of tx.outputs)
            this.write_output(output);
        this.write_buffer((tx.locktime instanceof uint32Little_1.UInt32Little ?
            tx.locktime : uint32Little_1.UInt32Little.fromNumber((!tx.locktime) ?
            0 : tx.locktime)).buffer);
    }
}
// write a transaction in the format given above to a buffer
function writeTransaction(tx) {
    let w = new Writer(serializedSize(tx));
    w.write_transaction(tx);
    return w.buf;
}
exports.writeTransaction = writeTransaction;
// (step 4) write incomplete transaction for signing.
function writeIncompleteTransaction(tx) {
    let inputs = [];
    for (let input of tx.inputs)
        inputs.push({
            prevTxId: input.prevTxId,
            outputIndex: input.outputIndex,
            script: Buffer.alloc(0),
            sequenceNumber: input.sequenceNumber
        });
    return writeTransaction({
        version: tx.version,
        inputs: inputs,
        outputs: tx.outputs,
        locktime: tx.locktime
    });
}
exports.writeIncompleteTransaction = writeIncompleteTransaction;
function sign(wif, doc, sigtype = bsv.crypto.Signature.SIGHASH_ALL | bsv.crypto.Signature.SIGHASH_FORKID, flags = bsv.Script.Interpreter.SCRIPT_VERIFY_MINIMALDATA |
    bsv.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID |
    bsv.Script.Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES |
    bsv.Script.Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES) {
    let tx = doc.incompleteTransaction instanceof bsv.Transaction ||
        doc.incompleteTransaction instanceof Buffer ?
        doc.incompleteTransaction :
        writeIncompleteTransaction(doc.incompleteTransaction);
    return Buffer.concat([
        bsv.Transaction.Sighash.sign(new bsv.Transaction(tx), new bsv.PrivateKey(wif), sigtype, doc.inputIndex, new bsv.Script(doc.scriptCode), new bsv.crypto.BN(doc.satoshis), flags).toBuffer(),
        Buffer.from([sigtype & 0xff])
    ]);
}
exports.sign = sign;
function verify(pubkey, sig, doc, flags = bsv.Script.Interpreter.SCRIPT_VERIFY_MINIMALDATA |
    bsv.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID |
    bsv.Script.Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES |
    bsv.Script.Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES) {
    let tx = doc.incompleteTransaction instanceof bsv.Transaction ||
        doc.incompleteTransaction instanceof Buffer ?
        doc.incompleteTransaction :
        writeIncompleteTransaction(doc.incompleteTransaction);
    let pub = pubkey instanceof Buffer ? bsv.PublicKey.fromBuffer(pubkey) : pubkey;
    return bsv.Transaction.Sighash.verify(new bsv.Transaction(tx), new bsv.crypto.Signature.fromTxFormat(sig), pub, doc.inputIndex, new bsv.Script(doc.scriptCode), new bsv.crypto.BN(doc.satoshis), flags);
}
exports.verify = verify;
