"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Job = void 0;
const bsv = require("./bsv");
const int32Little_1 = require("./fields/int32Little");
const uint32Little_1 = require("./fields/uint32Little");
const uint16Little_1 = require("./fields/uint16Little");
const digest32_1 = require("./fields/digest32");
const bytes_1 = require("./fields/bytes");
const difficulty_1 = require("./fields/difficulty");
const work = require("./work/proof");
const metadata_1 = require("./metadata");
const utils_1 = require("./utils");
const output_1 = require("./output");
const puzzle_1 = require("./puzzle");
class Job {
    constructor(
    // The hash of the content to be boosted.
    Content, 
    // how much it is to be boosted.
    Difficulty, 
    // corresponds to the version field in a bitcoin block header.
    // when we use ASICBoost, only half these bytes are avalable
    // to be whatever the user wants.
    Category, 
    // Up to 20 bytes. One tag per boost.
    Tag, 
    // Hold whatever other information you want here.
    AdditionalData, 
    // used to ensure no two boosts have the same script unless
    // the user wants it.
    UserNonce, 
    // whether we are using version 1 of the script or version 2,
    // which enables ASICBoost.
    useGeneralPurposeBits, 
    // the address of the miner will completed this boost.
    // used to ensure that other miners cannot steal the miner's nonce
    // for themselves.
    //
    // Optional because boost bounty adds it in the redeem script instead
    // of the locking script. If it is present, then his is a boost
    // contract script.
    MinerPubKeyHash, 
    // Optional tx information attached or not
    Txid, Vout, Value) {
        this.Content = Content;
        this.Difficulty = Difficulty;
        this.Category = Category;
        this.Tag = Tag;
        this.AdditionalData = AdditionalData;
        this.UserNonce = UserNonce;
        this.useGeneralPurposeBits = useGeneralPurposeBits;
        this.MinerPubKeyHash = MinerPubKeyHash;
        this.Txid = Txid;
        this.Vout = Vout;
        this.Value = Value;
    }
    get category() {
        return this.Category;
    }
    get content() {
        return this.Content;
    }
    get tag() {
        return this.Tag;
    }
    get additionalData() {
        return this.AdditionalData;
    }
    get userNonce() {
        return this.UserNonce;
    }
    get difficulty() {
        return this.Difficulty;
    }
    get bits() {
        return uint32Little_1.UInt32Little.fromNumber(utils_1.Utils.difficulty2bits(this.difficulty));
    }
    get minerPubKeyHash() {
        return this.MinerPubKeyHash;
    }
    get id() {
        return this.scriptHash;
    }
    get scriptVersion() {
        if (this.useGeneralPurposeBits)
            return 2;
        return 1;
    }
    get useASICBoost() {
        return this.scriptVersion > 1;
    }
    isContract() {
        return !!this.MinerPubKeyHash;
    }
    isBounty() {
        return !this.MinerPubKeyHash;
    }
    // the 16 bits of category that can be set by the user.
    get magicNumber() {
        return uint16Little_1.UInt16Little.fromNumber(utils_1.Utils.magicNumber(this.category.number));
    }
    static fromObject(params) {
        if (params.content && params.content.length > 64) {
            throw new Error('content too large. Max 32 bytes.');
        }
        if (params.diff <= 0 || isNaN(params.diff) || (typeof params.diff !== 'number')) {
            throw new Error('diff must be a positive number.');
        }
        let category;
        if (params.category) {
            if (params.category.length > 8) {
                throw new Error('category too large. Max 4 bytes.');
            }
            category = new int32Little_1.Int32Little(utils_1.Utils.createBufferAndPad(params.category, 4, false));
        }
        else {
            category = int32Little_1.Int32Little.fromNumber(0);
        }
        if (params.tag && params.tag.length > 40) {
            throw new Error('tag too large. Max 20 bytes.');
        }
        if (params.userNonce && params.userNonce.length > 8) {
            throw new Error('userNonce too large. Max 4 bytes.');
        }
        let userNonce;
        if (!params.userNonce) {
            let getRandomInt = (max) => {
                return Math.floor(Math.random() * max);
            };
            let tempBuffer = Buffer.from([getRandomInt(0xff), getRandomInt(0xff), getRandomInt(0xff), getRandomInt(0xff)]);
            userNonce = tempBuffer.toString('hex');
        }
        else {
            userNonce = params.userNonce;
        }
        let minerPubKeyHash;
        if (params.minerPubKeyHash) {
            if (params.minerPubKeyHash.length > 40) {
                throw new Error('minerPubKeyHash too large. Max 4 bytes.');
            }
            minerPubKeyHash = new bytes_1.Bytes(Buffer.from(params.minerPubKeyHash, 'hex'));
        }
        return new Job(new digest32_1.Digest32(utils_1.Utils.createBufferAndPad(params.content, 32)), params.diff, category, new bytes_1.Bytes(params.tag ? Buffer.from(params.tag, 'hex') : Buffer.alloc(0)), new bytes_1.Bytes(params.additionalData ? Buffer.from(params.additionalData, 'hex') : Buffer.alloc(0)), new uint32Little_1.UInt32Little(utils_1.Utils.createBufferAndPad(userNonce, 4, false)), params.useGeneralPurposeBits ? params.useGeneralPurposeBits : false, minerPubKeyHash);
    }
    toObject() {
        if (this.minerPubKeyHash) {
            return {
                content: this.content.hex,
                diff: this.difficulty,
                category: this.category.hex,
                tag: this.tag.hex,
                additionalData: this.additionalData.hex,
                userNonce: this.userNonce.hex,
                minerPubKeyHash: this.minerPubKeyHash.hex,
                useGeneralPurposeBits: this.useGeneralPurposeBits
            };
        }
        else {
            return {
                content: this.content.hex,
                diff: this.difficulty,
                category: this.category.hex,
                tag: this.tag.hex,
                additionalData: this.additionalData.hex,
                userNonce: this.userNonce.hex,
                useGeneralPurposeBits: this.useGeneralPurposeBits
            };
        }
    }
    toHex() {
        return this.toScript().toHex();
    }
    toBuffer() {
        return this.toScript().toBuffer();
    }
    toOpCode(num) {
        if (num.length == 1) {
            if (num[0] >= 1 && num[0] <= 16) {
                return bsv.Opcode.OP_1 + (num[0] - 1);
            }
            if (num[0] == 0x81) {
                return bsv.Opcode.OP_1NEGATE;
            }
        }
        return num;
    }
    toScript() {
        let buildOut = bsv.Script();
        buildOut.add(this.toOpCode(Buffer.from('boostpow', 'utf8')));
        buildOut.add(bsv.Opcode.OP_DROP);
        if (this.minerPubKeyHash) {
            buildOut.add(this.toOpCode(this.minerPubKeyHash.buffer));
        }
        buildOut.add(this.toOpCode(this.category.buffer));
        buildOut.add(this.toOpCode(this.content.buffer));
        buildOut.add(this.toOpCode(this.bits.buffer));
        buildOut.add(this.toOpCode(this.tag.buffer));
        buildOut.add(this.toOpCode(this.userNonce.buffer));
        buildOut.add(this.toOpCode(this.additionalData.buffer));
        // Add the rest of the script
        for (const op of Job.scriptOperations(this.useGeneralPurposeBits)) {
            buildOut.add(op);
        }
        // Return script
        return buildOut;
    }
    static remainingOperationsMatchExactly(remainingChunks, start, expectedOps) {
        let i = 0;
        if ((remainingChunks.length - start) !== expectedOps.length) {
            return false;
        }
        while (i < (remainingChunks.length - start)) {
            if ((
            // If it's a buffer, then ensure the value matches expect length
            remainingChunks[start + i].buf && (remainingChunks[start + i].len === expectedOps[i].length))
                ||
                    (remainingChunks[start + i].buf === undefined &&
                        expectedOps[i] === remainingChunks[start + i].opcodenum)) {
                i++;
            }
            else {
                return false;
            }
        }
        return true;
    }
    static readScript(script, txid, vout, value) {
        let category;
        let content;
        let diff;
        let tag;
        let additionalData;
        let userNonce;
        let minerPubKeyHash;
        let useGeneralPurposeBits;
        if (!(script.chunks[0].buf.toString('utf8') === 'boostpow' &&
            // Drop the identifier
            script.chunks[1].opcodenum === bsv.Opcode.OP_DROP))
            throw new Error('Invalid: no "boostpow" flag');
        let is_bounty;
        if (
        // Category
        script.chunks[2].buf &&
            script.chunks[2].opcodenum === 4) {
            is_bounty = true;
        }
        else if (
        // minerPubKeyHash
        script.chunks[2].buf &&
            script.chunks[2].opcodenum === 20) {
            is_bounty = false;
        }
        else
            throw new Error('Invalid: could not detect bounty or contract pattern');
        if (is_bounty) {
            if (
            // Content
            script.chunks[3].buf &&
                script.chunks[3].len === 32 &&
                // Target
                script.chunks[4].buf &&
                script.chunks[4].len === 4 &&
                // Tag
                ((script.chunks[5].buf && script.chunks[5].len <= 20) ||
                    script.chunks[5].opcodenum == bsv.Opcode.OP_0 ||
                    script.chunks[5].opcodenum == bsv.Opcode.OP_1NEGATE ||
                    (script.chunks[5].opcodenum >= bsv.Opcode.OP_1 && script.chunks[5].opcodenum <= bsv.Opcode.OP_16)) &&
                // User Nonce
                script.chunks[6].buf &&
                script.chunks[6].len === 4 &&
                // Additional Data
                (script.chunks[7].buf || script.chunks[7].opcodenum == bsv.Opcode.OP_0 ||
                    script.chunks[7].opcodenum == bsv.Opcode.OP_1NEGATE ||
                    (script.chunks[7].opcodenum >= bsv.Opcode.OP_1 && script.chunks[7].opcodenum <= bsv.Opcode.OP_16))) {
                if (Job.remainingOperationsMatchExactly(script.chunks, 8, Job.scriptOperationsV1NoASICBoost())) {
                    useGeneralPurposeBits = false;
                }
                else if (Job.remainingOperationsMatchExactly(script.chunks, 8, Job.scriptOperationsV2ASICBoost())) {
                    useGeneralPurposeBits = true;
                }
                else
                    throw new Error('Invalid script program');
                category = new int32Little_1.Int32Little(utils_1.Utils.fromOpCode(script.chunks[2]));
                content = new digest32_1.Digest32(utils_1.Utils.fromOpCode(script.chunks[3]));
                let targetHex = (utils_1.Utils.fromOpCode(script.chunks[4]).toString('hex').match(/../g) || []).reverse().join('');
                let targetInt = parseInt(targetHex, 16);
                diff = utils_1.Utils.difficulty(targetInt);
                tag = new bytes_1.Bytes(utils_1.Utils.fromOpCode(script.chunks[5]));
                userNonce = new uint32Little_1.UInt32Little(utils_1.Utils.fromOpCode(script.chunks[6]));
                additionalData = new bytes_1.Bytes(utils_1.Utils.fromOpCode(script.chunks[7]));
            }
            else
                throw new Error('Not valid Boost Output');
        }
        else {
            if (
            // Category
            script.chunks[3].buf &&
                script.chunks[3].opcodenum === 4 &&
                // Content
                script.chunks[4].buf &&
                script.chunks[4].len === 32 &&
                // Target
                script.chunks[5].buf &&
                script.chunks[5].len === 4 &&
                // Tag
                ((script.chunks[6].buf && script.chunks[6].len <= 20) ||
                    script.chunks[6].opcodenum == bsv.Opcode.OP_0 ||
                    script.chunks[6].opcodenum == bsv.Opcode.OP_1NEGATE ||
                    (script.chunks[6].opcodenum >= bsv.Opcode.OP_1 && script.chunks[6].opcodenum <= bsv.Opcode.OP_16)) &&
                // User Nonce
                script.chunks[7].buf &&
                script.chunks[7].len === 4 &&
                // Additional Data
                (script.chunks[8].buf ||
                    script.chunks[8].opcodenum == bsv.Opcode.OP_0 ||
                    script.chunks[8].opcodenum == bsv.Opcode.OP_1NEGATE ||
                    (script.chunks[8].opcodenum >= bsv.Opcode.OP_1 && script.chunks[8].opcodenum <= bsv.Opcode.OP_16))) {
                if (Job.remainingOperationsMatchExactly(script.chunks, 9, Job.scriptOperationsV1NoASICBoost())) {
                    useGeneralPurposeBits = false;
                }
                else if (Job.remainingOperationsMatchExactly(script.chunks, 9, Job.scriptOperationsV2ASICBoost())) {
                    useGeneralPurposeBits = true;
                }
                else
                    throw new Error('Not valid Boost Output');
                minerPubKeyHash = new bytes_1.Bytes(utils_1.Utils.fromOpCode(script.chunks[2]));
                category = new int32Little_1.Int32Little(utils_1.Utils.fromOpCode(script.chunks[3]));
                content = new digest32_1.Digest32(utils_1.Utils.fromOpCode(script.chunks[4]));
                let targetHex = (utils_1.Utils.fromOpCode(script.chunks[5]).toString('hex').match(/../g) || []).reverse().join('');
                let targetInt = parseInt(targetHex, 16);
                diff = utils_1.Utils.difficulty(targetInt);
                tag = new bytes_1.Bytes(utils_1.Utils.fromOpCode(script.chunks[6]));
                userNonce = new uint32Little_1.UInt32Little(utils_1.Utils.fromOpCode(script.chunks[7]));
                additionalData = new bytes_1.Bytes(utils_1.Utils.fromOpCode(script.chunks[8]));
            }
            else
                throw new Error('Invalid boost format');
        }
        return new Job(content, diff, category, tag, additionalData, userNonce, useGeneralPurposeBits, minerPubKeyHash, txid, vout, value);
    }
    static fromHex(asm, txid, vout, value) {
        return Job.readScript(new bsv.Script(asm), txid, vout, value);
    }
    static fromASM(asm, txid, vout, value) {
        return Job.readScript(new bsv.Script.fromASM(asm), txid, vout, value);
    }
    static fromBuffer(b, txid, vout, value) {
        return Job.readScript(new bsv.Script.fromBuffer(b), txid, vout, value);
    }
    toASM() {
        const makeHex = this.toHex();
        const makeAsm = new bsv.Script(makeHex);
        return makeAsm.toASM();
    }
    static fromASM4(str, txid, vout, value) {
        return Job.fromHex(str, txid, vout, value);
    }
    static fromASM2(str, txid, vout, value) {
        return Job.fromHex(str, txid, vout, value);
    }
    toString() {
        const makeHex = this.toHex();
        const makeAsm = new bsv.Script(makeHex);
        return makeAsm.toString();
    }
    static fromString(str, txid, vout, value) {
        return Job.fromHex(str, txid, vout, value);
    }
    // Optional attached information if available
    get txOutpoint() {
        return {
            txid: this.txid,
            vout: this.vout,
            value: this.value,
        };
    }
    // Optional attached information if available
    get txid() {
        return this.Txid;
    }
    // Optional attached information if available
    get vout() {
        return this.Vout;
    }
    // Optional attached information if available
    get value() {
        return this.Value;
    }
    get scriptHash() {
        const hex = this.toHex();
        const buffer = Buffer.from(hex, 'hex');
        return bsv.crypto.Hash.sha256(buffer).reverse().toString('hex');
    }
    static fromTransaction(t, vout = 0) {
        if (!t) {
            return undefined;
        }
        let tx = new bsv.Transaction(t);
        if (vout > tx.outputs.length - 1 || vout < 0 || vout === undefined || vout === null) {
            return undefined;
        }
        if (tx.outputs[vout].script && tx.outputs[vout].script.chunks[0].buf &&
            tx.outputs[vout].script.chunks[0].buf.toString('hex') === Buffer.from('boostpow', 'utf8').toString('hex')) {
            return Job.readScript(tx.outputs[vout].script, tx.hash, vout, tx.outputs[vout].satoshis);
        }
        return undefined;
    }
    static fromTransactionGetAllOutputs(tx) {
        if (!tx) {
            return [];
        }
        const boostJobs = [];
        let o = 0;
        for (const out of tx.outputs) {
            if (out.script && out.script.chunks[0].buf &&
                out.script.chunks[0].buf.toString('hex') === Buffer.from('boostpow', 'utf8').toString('hex')) {
                boostJobs.push(Job.readScript(out.script, tx.hash, o, out.satoshis));
            }
            o++;
        }
        return boostJobs;
    }
    static fromRawTransaction(rawtx, vout = 0) {
        if (isNaN(vout)) {
            return undefined;
        }
        const tx = new bsv.Transaction(rawtx);
        return Job.fromTransaction(tx, vout);
    }
    /**
     * Create a transaction fragment that can be modified to redeem the boost job
     *
     * @param boostPowJob Boost Job to redeem
     * @param boostPowJobProof Boost job proof to use to redeem
     * @param privateKey The private key string of the minerPubKeyHash
     */
    static createRedeemTransaction(boostPowJob, boostPowJobProof, privateKeyStr, receiveAddressStr, sats_per_byte = .5) {
        const boostPowString = Job.tryValidateJobProof(boostPowJob, boostPowJobProof);
        if (!boostPowString) {
            throw new Error('createRedeemTransaction: Invalid Job Proof');
        }
        if (boostPowJob.value === undefined)
            throw new Error('createRedeemTransaction: job requires satoshi value');
        if (boostPowJob.txid === undefined)
            throw new Error('createRedeemTransaction: job requires txid');
        if (boostPowJob.vout === undefined)
            throw new Error('createRedeemTransaction: job requires vout');
        return new bsv.Transaction(new puzzle_1.Puzzle(new output_1.Output(boostPowJob), privateKeyStr).createRedeemTransaction(boostPowJobProof.solution, receiveAddressStr, sats_per_byte));
    }
    static puzzle(boostPowJob, address) {
        let minerPubKeyHash;
        if (boostPowJob.isBounty() && address !== undefined) {
            minerPubKeyHash = address;
        }
        else if (boostPowJob.isContract() && address === undefined) {
            minerPubKeyHash = boostPowJob.minerPubKeyHash;
        }
        else
            throw "invalid";
        let meta_begin = new bytes_1.Bytes(Buffer.concat([
            boostPowJob.tag.buffer,
            minerPubKeyHash.buffer
        ]));
        let meta_end = new bytes_1.Bytes(Buffer.concat([
            boostPowJob.userNonce.buffer,
            boostPowJob.additionalData.buffer
        ]));
        return boostPowJob.useGeneralPurposeBits ?
            new work.Puzzle(boostPowJob.category, boostPowJob.content, new difficulty_1.Difficulty(boostPowJob.difficulty), meta_begin, meta_end, int32Little_1.Int32Little.fromNumber(utils_1.Utils.generalPurposeBitsMask())) : new work.Puzzle(boostPowJob.category, boostPowJob.content, new difficulty_1.Difficulty(boostPowJob.difficulty), meta_begin, meta_end);
    }
    static createBoostPowMetadata(boostPowJob, boostPowJobProof) {
        let minerPubKeyHash;
        if (boostPowJobProof.minerPubKeyHash) {
            minerPubKeyHash = boostPowJobProof.minerPubKeyHash;
        }
        else if (boostPowJob.minerPubKeyHash) {
            minerPubKeyHash = boostPowJob.minerPubKeyHash;
        }
        else
            throw "invalid proof";
        return metadata_1.Metadata.fromBuffer({
            tag: boostPowJob.tag.buffer,
            minerPubKeyHash: minerPubKeyHash.buffer,
            extraNonce1: boostPowJobProof.extraNonce1.buffer,
            extraNonce2: boostPowJobProof.extraNonce2.buffer,
            userNonce: boostPowJob.userNonce.buffer,
            additionalData: boostPowJob.additionalData.buffer,
        });
    }
    static proof(boostPowJob, boostPowJobProof) {
        const meta = Job.createBoostPowMetadata(boostPowJob, boostPowJobProof);
        let meta_begin = new bytes_1.Bytes(Buffer.concat([
            meta.tag.buffer,
            meta.minerPubKeyHash.buffer
        ]));
        let meta_end = new bytes_1.Bytes(Buffer.concat([
            meta.userNonce.buffer,
            meta.additionalData.buffer
        ]));
        let z;
        if (boostPowJob.useGeneralPurposeBits) {
            z = new work.Puzzle(boostPowJob.category, boostPowJob.content, new difficulty_1.Difficulty(boostPowJob.difficulty), meta_begin, meta_end, int32Little_1.Int32Little.fromNumber(utils_1.Utils.generalPurposeBitsMask()));
        }
        else {
            z = new work.Puzzle(boostPowJob.category, boostPowJob.content, new difficulty_1.Difficulty(boostPowJob.difficulty), meta_begin, meta_end);
        }
        return new work.Proof(z, boostPowJobProof.solution);
    }
    static tryValidateJobProof(boostPowJob, boostPowJobProof) {
        let x = this.proof(boostPowJob, boostPowJobProof).string();
        if (!(x && x.valid()))
            return null;
        return {
            boostPowString: x,
            boostPowMetadata: Job.createBoostPowMetadata(boostPowJob, boostPowJobProof)
        };
    }
    static loopOperation(loopIterations, generateFragmentInvoker) {
        let concatOps = [];
        for (let i = 0; i < loopIterations; i++) {
            concatOps = concatOps.concat(generateFragmentInvoker());
        }
        return concatOps;
    }
    static scriptOperations(useGeneralPurposeBits) {
        if (useGeneralPurposeBits)
            return this.scriptOperationsV2ASICBoost();
        return this.scriptOperationsV1NoASICBoost();
    }
    static scriptOperationsV1NoASICBoost() {
        return [
            // CAT SWAP
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            // {5} ROLL DUP TOALTSTACK CAT                // copy mining pool’s pubkey hash to alt stack. A copy remains on the stack.
            bsv.Opcode.OP_5,
            bsv.Opcode.OP_ROLL,
            bsv.Opcode.OP_DUP,
            bsv.Opcode.OP_TOALTSTACK,
            bsv.Opcode.OP_CAT,
            // {2} PICK TOALTSTACK                         // copy target and push to altstack.
            bsv.Opcode.OP_2,
            bsv.Opcode.OP_PICK,
            bsv.Opcode.OP_TOALTSTACK,
            // {5} ROLL SIZE {4} EQUALVERIFY CAT          // check size of extra_nonce_1
            bsv.Opcode.OP_5,
            bsv.Opcode.OP_ROLL,
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_4,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CAT,
            // {5} ROLL SIZE {8} EQUALVERIFY CAT          // check size of extra_nonce_2
            bsv.Opcode.OP_5,
            bsv.Opcode.OP_ROLL,
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_8,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CAT,
            // SWAP CAT HASH256                           // create metadata string and hash it.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_HASH256,
            // SWAP TOALTSTACK CAT CAT                    // target to altstack.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_TOALTSTACK,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT              // check size of timestamp.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_4,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CAT,
            // FROMALTSTACK CAT                           // attach target
            bsv.Opcode.OP_FROMALTSTACK,
            bsv.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT             // check size of nonce. Boost POW string is constructed.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_4,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CAT,
            // Take hash of work string and ensure that it is positive and minimally encoded.
            bsv.Opcode.OP_HASH256, ...Job.ensure_positive(),
            bsv.Opcode.OP_FROMALTSTACK, ...Job.expand_target(), ...Job.ensure_positive(),
            // check that the hash of the Boost POW string is less than the target
            bsv.Opcode.OP_LESSTHAN,
            bsv.Opcode.OP_VERIFY,
            // check that the given address matches the pubkey and check signature.
            // DUP HASH160 FROMALTSTACK EQUALVERIFY CHECKSIG
            bsv.Opcode.OP_DUP,
            bsv.Opcode.OP_HASH160,
            bsv.Opcode.OP_FROMALTSTACK,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CHECKSIG,
        ];
    }
    static scriptOperationsV2ASICBoost() {
        return [
            // CAT SWAP
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            // {5} ROLL DUP TOALTSTACK CAT                // copy mining pool’s pubkey hash to alt stack. A copy remains on the stack.
            bsv.Opcode.OP_5,
            bsv.Opcode.OP_ROLL,
            bsv.Opcode.OP_DUP,
            bsv.Opcode.OP_TOALTSTACK,
            bsv.Opcode.OP_CAT,
            // {2} PICK TOALTSTACK                         // copy target and push to altstack.
            bsv.Opcode.OP_2,
            bsv.Opcode.OP_PICK,
            bsv.Opcode.OP_TOALTSTACK,
            // {6} ROLL SIZE {4} EQUALVERIFY CAT          // check size of extra_nonce_1
            bsv.Opcode.OP_6,
            bsv.Opcode.OP_ROLL,
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_4,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CAT,
            // {6} ROLL SIZE {8} EQUALVERIFY CAT          // check size of extra_nonce_2
            bsv.Opcode.OP_6,
            bsv.Opcode.OP_ROLL,
            bsv.Opcode.OP_SIZE,
            Buffer.from("0120", "hex"),
            bsv.Opcode.OP_GREATERTHANOREQUAL,
            bsv.Opcode.OP_VERIFY,
            bsv.Opcode.OP_CAT,
            // SWAP CAT HASH256                           // create metadata string and hash it.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_HASH256,
            // SWAP TOALTSTACK CAT CAT                    // target and content + merkleroot to altstack.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_TOALTSTACK,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_TOALTSTACK,
            Buffer.from("ff1f00e0", "hex"),
            bsv.Opcode.OP_DUP,
            bsv.Opcode.OP_INVERT,
            bsv.Opcode.OP_TOALTSTACK,
            bsv.Opcode.OP_AND,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_FROMALTSTACK,
            bsv.Opcode.OP_AND,
            bsv.Opcode.OP_OR,
            bsv.Opcode.OP_FROMALTSTACK,
            bsv.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT              // check size of timestamp.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_4,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CAT,
            // FROMALTSTACK CAT                           // attach target
            bsv.Opcode.OP_FROMALTSTACK,
            bsv.Opcode.OP_CAT,
            // SWAP SIZE {4} EQUALVERIFY CAT             // check size of nonce. Boost POW string is constructed.
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_4,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CAT,
            // Take hash of work string and ensure that it is positive and minimally encoded.
            bsv.Opcode.OP_HASH256, ...Job.ensure_positive(),
            bsv.Opcode.OP_FROMALTSTACK, ...Job.expand_target(), ...Job.ensure_positive(),
            // check that the hash of the Boost POW string is less than the target
            bsv.Opcode.OP_LESSTHAN,
            bsv.Opcode.OP_VERIFY,
            // check that the given address matches the pubkey and check signature.
            // DUP HASH160 FROMALTSTACK EQUALVERIFY CHECKSIG
            bsv.Opcode.OP_DUP,
            bsv.Opcode.OP_HASH160,
            bsv.Opcode.OP_FROMALTSTACK,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_CHECKSIG,
        ];
    }
    /*
    expand_target - transforms the uint32 exponential (compact) format for the difficulty target into the full uint256 value.
    */
    static expand_target() {
        return [
            bsv.Opcode.OP_SIZE,
            bsv.Opcode.OP_4,
            bsv.Opcode.OP_EQUALVERIFY,
            bsv.Opcode.OP_3,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_DUP,
            bsv.Opcode.OP_BIN2NUM,
            bsv.Opcode.OP_3,
            Buffer.from('21', 'hex'),
            bsv.Opcode.OP_WITHIN,
            bsv.Opcode.OP_VERIFY,
            bsv.Opcode.OP_TOALTSTACK,
            bsv.Opcode.OP_DUP,
            bsv.Opcode.OP_BIN2NUM,
            bsv.Opcode.OP_0,
            bsv.Opcode.OP_GREATERTHAN,
            bsv.Opcode.OP_VERIFY,
            Buffer.from('0000000000000000000000000000000000000000000000000000000000', 'hex'),
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_FROMALTSTACK,
            bsv.Opcode.OP_3,
            bsv.Opcode.OP_SUB,
            bsv.Opcode.OP_8,
            bsv.Opcode.OP_MUL,
            bsv.Opcode.OP_RSHIFT,
        ];
    }
    /*
    Numbers in Bitcoin script are in little endian and the last bit is a sign bit.
    However, the target and the hash digest are both supposed to be positive
    numbers. Thus, we have to attach an extra byte of zeros to numbers if they
    would be treated as negative in Bitcoin script.
    */
    static ensure_positive() {
        return [
            Buffer.from('00', 'hex'),
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_BIN2NUM
        ];
    }
    // reverse endianness. Cuz why not?
    static reverse32() {
        return [
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_1,
            bsv.Opcode.OP_SPLIT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
            bsv.Opcode.OP_SWAP,
            bsv.Opcode.OP_CAT,
        ];
    }
}
exports.Job = Job;
