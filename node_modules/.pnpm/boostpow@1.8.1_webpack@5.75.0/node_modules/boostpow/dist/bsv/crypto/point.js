"use strict";var BN=require("./bn"),EC=require("elliptic").ec,ec=new EC("secp256k1"),ecPoint=ec.curve.point.bind(ec.curve),ecPointFromX=ec.curve.pointFromX.bind(ec.curve),Point=function(t,e,o){try{var r=ecPoint(t,e,o)}catch(t){throw new Error("Invalid Point")}return r.validate(),r};Point.prototype=Object.getPrototypeOf(ec.curve.point()),Point.fromX=function(t,e){try{var o=ecPointFromX(e,t)}catch(t){throw new Error("Invalid X")}return o.validate(),o},Point.getG=function(){return ec.curve.g},Point.getN=function(){return new BN(ec.curve.n.toArray())},Point.prototype._getX||(Point.prototype._getX=Point.prototype.getX),Point.prototype.getX=function(){return new BN(this._getX().toArray())},Point.prototype._getY||(Point.prototype._getY=Point.prototype.getY),Point.prototype.getY=function(){return new BN(this._getY().toArray())},Point.prototype.validate=function(){if(this.isInfinity())throw new Error("Point cannot be equal to Infinity");var t;try{t=ecPointFromX(this.getX(),this.getY().isOdd())}catch(t){throw new Error("Point does not lie on the curve")}if(0!==t.y.cmp(this.y))throw new Error("Invalid y value for curve.");if(!this.mul(Point.getN()).isInfinity())throw new Error("Point times N must be infinity");return this},Point.pointToCompressed=function(t){var e,o=t.getX().toBuffer({size:32}),r=t.getY().toBuffer({size:32});return e=r[r.length-1]%2?Buffer.from([3]):Buffer.from([2]),Buffer.concat([e,o])},Point.pointFromCompressed=function(t){if(33!==t.length)throw new Error("invalid buffer length");let e,o=t[0];if(3===o)e=!0;else{if(2!==o)throw new Error("invalid value of compressed prefix");e=!1}let r=t.slice(1,33),n=BN.fromBuffer(r);return Point.fromX(e,n)},Point.prototype.toBuffer=function(){return Point.pointToCompressed(this)},Point.prototype.toHex=function(){return this.toBuffer().toString("hex")},Point.fromBuffer=function(t){return Point.pointFromCompressed(t)},Point.fromHex=function(t){return Point.fromBuffer(Buffer.from(t,"hex"))},module.exports=Point;