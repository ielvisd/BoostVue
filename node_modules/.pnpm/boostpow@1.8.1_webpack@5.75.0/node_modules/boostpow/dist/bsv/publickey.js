"use strict";var BN=require("./crypto/bn"),Point=require("./crypto/point"),Hash=require("./crypto/hash"),JSUtil=require("./util/javas"),Network=require("./networks"),_=require("./util/_"),$=require("./util/preconditions");function PublicKey(e,r){if(!(this instanceof PublicKey))return new PublicKey(e,r);if($.checkArgument(e,"First argument is required, please include public key data."),e instanceof PublicKey)return e;r=r||{};var t=this._classifyArgs(e,r);return t.point.validate(),JSUtil.defineImmutable(this,{point:t.point,compressed:t.compressed,network:t.network||Network.defaultNetwork}),this}PublicKey.prototype._classifyArgs=function(e,r){var t={compressed:_.isUndefined(r.compressed)||r.compressed};if(e instanceof Point)t.point=e;else if(e.x&&e.y)t=PublicKey._transformObject(e);else if("string"==typeof e)t=PublicKey._transformDER(Buffer.from(e,"hex"));else if(PublicKey._isBuffer(e))t=PublicKey._transformDER(e);else{if(!PublicKey._isPrivateKey(e))throw new TypeError("First argument is an unrecognized data format.");t=PublicKey._transformPrivateKey(e)}return t.network||(t.network=_.isUndefined(r.network)?void 0:Network.get(r.network)),t},PublicKey._isPrivateKey=function(e){return e instanceof require("./privatekey")},PublicKey._isBuffer=function(e){return e instanceof Buffer||e instanceof Uint8Array},PublicKey._transformPrivateKey=function(e){$.checkArgument(PublicKey._isPrivateKey(e),"Must be an instance of PrivateKey");var r={};return r.point=Point.getG().mul(e.bn),r.compressed=e.compressed,r.network=e.network,r},PublicKey._transformDER=function(e,r){$.checkArgument(PublicKey._isBuffer(e),"Must be a buffer of DER encoded public key");var t,i,n,o,u={};if(r=!!_.isUndefined(r)||r,4!==e[0]&&(r||6!==e[0]&&7!==e[0]))if(3===e[0])n=e.slice(1),t=new BN(n),(u=PublicKey._transformX(!0,t)).compressed=!0;else{if(2!==e[0])throw new TypeError("Invalid DER format public key");n=e.slice(1),t=new BN(n),(u=PublicKey._transformX(!1,t)).compressed=!0}else{if(n=e.slice(1,33),o=e.slice(33,65),32!==n.length||32!==o.length||65!==e.length)throw new TypeError("Length of x and y must be 32 bytes");t=new BN(n),i=new BN(o),u.point=new Point(t,i),u.compressed=!1}return u},PublicKey._transformX=function(e,r){$.checkArgument("boolean"==typeof e,"Must specify whether y is odd or not (true or false)");var t={};return t.point=Point.fromX(e,r),t},PublicKey._transformObject=function(e){var r=new BN(e.x,"hex"),t=new BN(e.y,"hex");return new PublicKey(new Point(r,t),{compressed:e.compressed})},PublicKey.fromPrivateKey=function(e){$.checkArgument(PublicKey._isPrivateKey(e),"Must be an instance of PrivateKey");var r=PublicKey._transformPrivateKey(e);return new PublicKey(r.point,{compressed:r.compressed,network:r.network})},PublicKey.fromDER=PublicKey.fromBuffer=function(e,r){$.checkArgument(PublicKey._isBuffer(e),"Must be a buffer of DER encoded public key");var t=PublicKey._transformDER(e,r);return new PublicKey(t.point,{compressed:t.compressed})},PublicKey.fromPoint=function(e,r){return $.checkArgument(e instanceof Point,"First argument must be an instance of Point."),new PublicKey(e,{compressed:r})},PublicKey.fromHex=PublicKey.fromString=function(e,r){var t=Buffer.from(e,r||"hex"),i=PublicKey._transformDER(t);return new PublicKey(i.point,{compressed:i.compressed})},PublicKey.fromX=function(e,r){var t=PublicKey._transformX(e,r);return new PublicKey(t.point,{compressed:t.compressed})},PublicKey.getValidationError=function(e){var r;try{new PublicKey(e)}catch(e){r=e}return r},PublicKey.isValid=function(e){return!PublicKey.getValidationError(e)},PublicKey.prototype.toObject=PublicKey.prototype.toJSON=function(){return{x:this.point.getX().toString("hex",2),y:this.point.getY().toString("hex",2),compressed:this.compressed}},PublicKey.prototype.toBuffer=PublicKey.prototype.toDER=function(){var e,r=this.point.getX(),t=this.point.getY(),i=r.toBuffer({size:32}),n=t.toBuffer({size:32});return this.compressed?(e=n[n.length-1]%2?Buffer.from([3]):Buffer.from([2]),Buffer.concat([e,i])):(e=Buffer.from([4]),Buffer.concat([e,i,n]))},PublicKey.prototype._getID=function(){return Hash.sha256ripemd160(this.toBuffer())},PublicKey.prototype.toAddress=function(e){return require("./address").fromPublicKey(this,e||this.network)},PublicKey.prototype.toString=PublicKey.prototype.toHex=function(){return this.toDER().toString("hex")},PublicKey.prototype.inspect=function(){return"<PublicKey: "+this.toHex()+(this.compressed?"":", uncompressed")+">"},module.exports=PublicKey;