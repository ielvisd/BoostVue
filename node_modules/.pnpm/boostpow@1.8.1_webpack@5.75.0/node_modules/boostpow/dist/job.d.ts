/// <reference types="node" />
import * as bsv from './bsv';
import { Int32Little } from './fields/int32Little';
import { UInt32Little } from './fields/uint32Little';
import { UInt16Little } from './fields/uint16Little';
import { Digest32 } from './fields/digest32';
import { Digest20 } from './fields/digest20';
import { Bytes } from './fields/bytes';
import * as work from './work/proof';
import { Redeem } from './redeem';
import { Metadata } from './metadata';
export declare class Job {
    private Content;
    private Difficulty;
    private Category;
    private Tag;
    private AdditionalData;
    private UserNonce;
    private useGeneralPurposeBits;
    private MinerPubKeyHash?;
    private Txid?;
    private Vout?;
    private Value?;
    private constructor();
    get category(): Int32Little;
    get content(): Digest32;
    get tag(): Bytes;
    get additionalData(): Bytes;
    get userNonce(): UInt32Little;
    get difficulty(): number;
    get bits(): UInt32Little;
    get minerPubKeyHash(): Digest20 | undefined;
    get id(): string;
    get scriptVersion(): number;
    get useASICBoost(): boolean;
    isContract(): boolean;
    isBounty(): boolean;
    get magicNumber(): UInt16Little;
    static fromObject(params: {
        content: string;
        diff: number;
        category?: string;
        tag?: string;
        additionalData?: string;
        userNonce?: string;
        minerPubKeyHash?: string;
        useGeneralPurposeBits?: boolean;
    }): Job;
    toObject(): {
        content: string;
        diff: number;
        category: string;
        tag: string;
        additionalData: string;
        userNonce: string;
        minerPubKeyHash: string;
        useGeneralPurposeBits: boolean;
    } | {
        content: string;
        diff: number;
        category: string;
        tag: string;
        additionalData: string;
        userNonce: string;
        useGeneralPurposeBits: boolean;
        minerPubKeyHash?: undefined;
    };
    toHex(): string;
    toBuffer(): Buffer;
    private toOpCode;
    toScript(): bsv.Script;
    static remainingOperationsMatchExactly(remainingChunks: any, start: number, expectedOps: any): boolean;
    private static readScript;
    static fromHex(asm: string, txid?: string, vout?: number, value?: number): Job;
    static fromASM(asm: string, txid?: string, vout?: number, value?: number): Job;
    static fromBuffer(b: Buffer, txid?: string, vout?: number, value?: number): Job;
    toASM(): string;
    static fromASM4(str: string, txid?: string, vout?: number, value?: number): Job;
    static fromASM2(str: string, txid?: string, vout?: number, value?: number): Job;
    toString(): string;
    static fromString(str: string, txid?: string, vout?: number, value?: number): Job;
    get txOutpoint(): {
        txid?: string;
        vout?: number;
        value?: number;
    };
    get txid(): string | undefined;
    get vout(): number | undefined;
    get value(): number | undefined;
    get scriptHash(): string;
    static fromTransaction(t: bsv.Transaction | Buffer | string, vout?: number): Job | undefined;
    static fromTransactionGetAllOutputs(tx: bsv.Transaction): Job[];
    static fromRawTransaction(rawtx: string, vout?: number): Job | undefined;
    /**
     * Create a transaction fragment that can be modified to redeem the boost job
     *
     * @param boostPowJob Boost Job to redeem
     * @param boostPowJobProof Boost job proof to use to redeem
     * @param privateKey The private key string of the minerPubKeyHash
     */
    static createRedeemTransaction(boostPowJob: Job, boostPowJobProof: Redeem, privateKeyStr: string, receiveAddressStr: string, sats_per_byte?: number): bsv.Transaction;
    static puzzle(boostPowJob: Job, address?: Digest20): work.Puzzle;
    static createBoostPowMetadata(boostPowJob: Job, boostPowJobProof: Redeem): Metadata;
    static proof(boostPowJob: Job, boostPowJobProof: Redeem): work.Proof;
    static tryValidateJobProof(boostPowJob: Job, boostPowJobProof: Redeem): null | {
        boostPowString: work.PowString;
        boostPowMetadata: Metadata;
    };
    static loopOperation(loopIterations: number, generateFragmentInvoker: Function): never[];
    static scriptOperations(useGeneralPurposeBits: boolean): any[];
    static scriptOperationsV1NoASICBoost(): any[];
    static scriptOperationsV2ASICBoost(): any[];
    static expand_target(): any[];
    static ensure_positive(): any[];
    static reverse32(): any[];
}
