"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Proof = exports.pow_string = exports.meta = exports.Solution = exports.Puzzle = exports.PowString = void 0;
const bsv = require("../bsv");
const int32Little_1 = require("../fields/int32Little");
const uint32Little_1 = require("../fields/uint32Little");
const uint32Big_1 = require("../fields/uint32Big");
const bytes_1 = require("../fields/bytes");
const utils_1 = require("../utils");
const string_1 = require("./string");
var string_2 = require("./string");
Object.defineProperty(exports, "PowString", { enumerable: true, get: function () { return string_2.PowString; } });
// TODO the puzzle also needs to contain a Merkle branch but for Boost that is empty.
class Puzzle {
    constructor(Category, Content, Difficulty, MetaBegin, MetaEnd, Mask) {
        this.Category = Category;
        this.Content = Content;
        this.Difficulty = Difficulty;
        this.MetaBegin = MetaBegin;
        this.MetaEnd = MetaEnd;
        this.Mask = Mask;
    }
}
exports.Puzzle = Puzzle;
class Solution {
    constructor(Time, ExtraNonce1, ExtraNonce2, Nonce, GeneralPurposeBits) {
        this.Time = Time;
        this.ExtraNonce1 = ExtraNonce1;
        this.ExtraNonce2 = ExtraNonce2;
        this.Nonce = Nonce;
        this.GeneralPurposeBits = GeneralPurposeBits;
    }
    toJSON() {
        let json = {
            share: {
                timestamp: this.Time.hex,
                nonce: this.Nonce.hex,
                extra_nonce_2: this.Nonce.hex
            },
            extra_nonce_1: this.ExtraNonce1.hex
        };
        if (this.GeneralPurposeBits)
            json.share["bits"] = this.GeneralPurposeBits.hex;
        return json;
    }
    static fromJSON(x) {
        if (!x.share || !x.extra_nonce_1 ||
            !x.share.timestamp || !x.share.nonce || !x.share.extra_nonce_2 ||
            typeof x.extra_nonce_1 !== 'string' ||
            typeof x.share.timestamp !== 'string' ||
            typeof x.share.nonce !== 'string' ||
            typeof x.share.extra_nonce_2 !== 'string' ||
            (!!x.share.bits && typeof x.share.bits !== 'string'))
            return;
        let time = uint32Little_1.UInt32Little.fromHex(x.share.timestamp);
        if (time === undefined)
            return;
        let en1 = uint32Big_1.UInt32Big.fromHex(x.extra_nonce_1);
        if (en1 === undefined)
            return;
        let en2 = bytes_1.Bytes.fromHex(x.share.extra_nonce_2);
        if (en2 === undefined)
            return;
        let n = uint32Little_1.UInt32Little.fromHex(x.share.nonce);
        if (n === undefined)
            return;
        let gpr;
        if (!!x.share.bits) {
            gpr = int32Little_1.Int32Little.fromHex(x.share.bits);
            if (gpr === undefined)
                return;
        }
        return new Solution(time, en1, en2, n, gpr);
    }
}
exports.Solution = Solution;
function meta(p, x) {
    return new bytes_1.Bytes(Buffer.concat([
        p.MetaBegin.buffer,
        x.ExtraNonce1.buffer,
        x.ExtraNonce2.buffer,
        p.MetaEnd.buffer
    ]));
}
exports.meta = meta;
function pow_string(p, x) {
    var category;
    if (p.Mask) {
        var generalPurposeBits = x.GeneralPurposeBits;
        if (generalPurposeBits) {
            category = utils_1.Utils.writeInt32LE((p.Category.number & p.Mask.number) |
                (generalPurposeBits.number & ~p.Mask.number));
        }
        else {
            return;
        }
    }
    else if (x.GeneralPurposeBits) {
        return;
    }
    else {
        category = p.Category.buffer;
    }
    const boostPowMetadataCoinbaseString = meta(p, x);
    return new string_1.PowString(bsv.BlockHeader.fromBuffer(Buffer.concat([
        category,
        p.Content.buffer,
        boostPowMetadataCoinbaseString.hash256.buffer,
        x.Time.buffer,
        p.Difficulty.buffer,
        x.Nonce.buffer,
    ])));
}
exports.pow_string = pow_string;
// TODO the puzzle also needs to contain a Merkle branch but for Boost that is empty.
class Proof {
    constructor(Puzzle, Solution) {
        this.Puzzle = Puzzle;
        this.Solution = Solution;
    }
    metadata() {
        return meta(this.Puzzle, this.Solution);
    }
    string() {
        return pow_string(this.Puzzle, this.Solution);
    }
    valid() {
        let x = this.string();
        if (x) {
            return x.valid();
        }
        return false;
    }
}
exports.Proof = Proof;
