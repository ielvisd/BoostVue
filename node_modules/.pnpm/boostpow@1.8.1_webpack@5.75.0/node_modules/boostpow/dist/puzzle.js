"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Puzzle = void 0;
const bsv = require("./bsv");
const work = require("./work/proof");
const job_1 = require("./job");
const redeem_1 = require("./redeem");
const digest20_1 = require("./fields/digest20");
const bytes_1 = require("./fields/bytes");
const tx_build = require("./transaction");
// Puzzle represents a Boost output that has had a private key assigned to it.
// This may have happened before or after the output was created, depending on
// whether it has a contract or bounty format.
class Puzzle {
    constructor(output, k) {
        let key = new bsv.PrivateKey(k);
        let pub = key.toPublicKey();
        let address = new digest20_1.Digest20(Buffer.from(bsv.Address.fromPublicKey(pub, key.network).toObject().hash, 'hex'));
        if (output.script.minerPubKeyHash) {
            if (!address.equals(output.script.minerPubKeyHash))
                throw "invalid parameters";
        }
        else
            this._address = address;
        this.output = output;
        this.key = key;
        this.pubkey = new bytes_1.Bytes(pub.toBuffer());
    }
    get address() {
        if (this._address)
            return this._address;
        return this.output.script.minerPubKeyHash;
    }
    get workPuzzle() {
        return job_1.Job.puzzle(this.output.script, this._address);
    }
    // create a redeem script for this output.
    redeem(solution, 
    // the incomplete tx that will be signed (the input scripts are missing)
    incomplete_transaction, 
    // the index of the input script that we are creating.
    input_index, sigtype = bsv.crypto.Signature.SIGHASH_ALL | bsv.crypto.Signature.SIGHASH_FORKID, flags = bsv.Script.Interpreter.SCRIPT_VERIFY_MINIMALDATA |
        bsv.Script.Interpreter.SCRIPT_ENABLE_SIGHASH_FORKID |
        bsv.Script.Interpreter.SCRIPT_ENABLE_MAGNETIC_OPCODES |
        bsv.Script.Interpreter.SCRIPT_ENABLE_MONOLITH_OPCODES) {
        if (!new work.Proof(this.workPuzzle, solution).valid())
            throw new Error('invalid solution');
        return redeem_1.Redeem.fromSolution(new bytes_1.Bytes(tx_build.sign(this.key, {
            satoshis: this.output.value,
            scriptCode: this.output.script.toScript(),
            inputIndex: input_index,
            incompleteTransaction: incomplete_transaction
        }, sigtype, flags)), this.pubkey, solution, this._address);
    }
    expectedRedeemScriptSize() {
        return redeem_1.Redeem.expectedSize(this.output.script.isBounty(), this.output.script.scriptVersion == 2, this.key.compressed);
    }
    createRedeemTransaction(solution, receiveAddress, sats_per_byte, op_return = [
        'boostpow',
        'proof'
    ]) {
        // step 1. create incomplete transaction.
        let tx = {
            version: 1,
            inputs: [
                {
                    prevTxId: this.output.txid.buffer,
                    outputIndex: this.output.vout,
                    scriptSize: this.expectedRedeemScriptSize()
                }
            ],
            outputs: [
                {
                    satoshis: 0,
                    script: bsv.Script(new bsv.Address(receiveAddress)).toBuffer()
                },
                {
                    satoshis: 0,
                    script: bsv.Script.buildSafeDataOut(op_return).toBuffer()
                }
            ]
        };
        // steps 2 - 3: get fee
        let fee = Math.ceil(tx_build.estimateTransactionSize(tx) * sats_per_byte);
        if (fee > this.output.value)
            throw "not enough sats to be worth it";
        tx.outputs[0].satoshis = this.output.value - fee;
        // steps 4 - 6
        return tx_build.writeTransaction({
            version: 1,
            inputs: [
                {
                    prevTxId: this.output.txid.buffer,
                    outputIndex: this.output.vout,
                    script: this.redeem(solution, tx, 0).toBuffer()
                }
            ],
            outputs: tx.outputs
        });
    }
}
exports.Puzzle = Puzzle;
