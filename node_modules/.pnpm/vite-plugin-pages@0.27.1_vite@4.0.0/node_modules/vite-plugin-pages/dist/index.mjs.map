{"version":3,"sources":["../src/constants.ts","../src/context.ts","../node_modules/.pnpm/@antfu+utils@0.5.2/node_modules/@antfu/utils/dist/index.mjs","../src/options.ts","../src/files.ts","../src/utils.ts","../src/resolvers/vue.ts","../src/stringify.ts","../src/customBlock.ts","../src/resolvers/react.ts","../src/resolvers/solid.ts","../src/index.ts"],"sourcesContent":["export const MODULE_IDS = [\n  '~pages',\n  '~react-pages',\n  '~solid-pages',\n  'pages-generated',\n  'virtual:generated-pages',\n  'virtual:generated-pages-react',\n]\n\nexport const MODULE_ID_VIRTUAL = '/@vite-plugin-pages/generated-pages'\nexport const ROUTE_BLOCK_ID_VIRTUAL = '/@vite-plugin-pages/route-block'\nexport const ROUTE_IMPORT_NAME = '__pages_import_$1__'\n\nexport const routeBlockQueryRE = /\\?vue&type=route/\n\nexport const dynamicRouteRE = /^\\[(.+)\\]$/\nexport const cacheAllRouteRE = /^\\[\\.{3}(.*)\\]$/\nexport const replaceDynamicRouteRE = /^\\[(?:\\.{3})?(.*)\\]$/\n\nexport const nuxtDynamicRouteRE = /^_(.*)$/\nexport const nuxtCacheAllRouteRE = /^_$/\n\nexport const countSlashRE = /\\//g\n\nexport const replaceIndexRE = /\\/?index$/\n","import { extname, join, resolve } from 'path'\nimport { slash, toArray } from '@antfu/utils'\nimport { resolveOptions } from './options'\nimport { getPageFiles } from './files'\nimport { debug, invalidatePagesModule, isTarget } from './utils'\n\nimport type { FSWatcher } from 'fs'\nimport type { Logger, ViteDevServer } from 'vite'\nimport type { PageOptions, ResolvedOptions, UserOptions } from './types'\n\nexport interface PageRoute {\n  path: string\n  route: string\n}\n\nexport class PageContext {\n  private _server: ViteDevServer | undefined\n  private _pageRouteMap = new Map<string, PageRoute>()\n\n  rawOptions: UserOptions\n  root: string\n  options: ResolvedOptions\n  logger?: Logger\n\n  constructor(userOptions: UserOptions, viteRoot: string = process.cwd()) {\n    this.rawOptions = userOptions\n    this.root = slash(viteRoot)\n    debug.env('root', this.root)\n    this.options = resolveOptions(userOptions, this.root)\n    debug.options(this.options)\n  }\n\n  setLogger(logger: Logger) {\n    this.logger = logger\n  }\n\n  setupViteServer(server: ViteDevServer) {\n    if (this._server === server)\n      return\n\n    this._server = server\n    this.setupWatcher(server.watcher)\n  }\n\n  setupWatcher(watcher: FSWatcher) {\n    watcher\n      .on('unlink', async(path) => {\n        path = slash(path)\n        if (!isTarget(path, this.options))\n          return\n        await this.removePage(path)\n        this.onUpdate()\n      })\n    watcher\n      .on('add', async(path) => {\n        path = slash(path)\n        if (!isTarget(path, this.options))\n          return\n        const page = this.options.dirs.find(i => path.startsWith(slash(resolve(this.root, i.dir))))!\n        await this.addPage(path, page)\n        this.onUpdate()\n      })\n\n    watcher\n      .on('change', async(path) => {\n        path = slash(path)\n        if (!isTarget(path, this.options))\n          return\n        const page = this._pageRouteMap.get(path)\n        if (page)\n          await this.options.resolver.hmr?.changed?.(this, path)\n      })\n  }\n\n  async addPage(path: string | string[], pageDir: PageOptions) {\n    debug.pages('add', path)\n    for (const p of toArray(path)) {\n      const pageDirPath = slash(resolve(this.root, pageDir.dir))\n      const route = slash(join(pageDir.baseRoute, p.replace(`${pageDirPath}/`, '').replace(extname(p), '')))\n      this._pageRouteMap.set(p, {\n        path: p,\n        route,\n      })\n      await this.options.resolver.hmr?.added?.(this, p)\n    }\n  }\n\n  async removePage(path: string) {\n    debug.pages('remove', path)\n    this._pageRouteMap.delete(path)\n    await this.options.resolver.hmr?.removed?.(this, path)\n  }\n\n  onUpdate() {\n    if (!this._server)\n      return\n\n    invalidatePagesModule(this._server)\n    debug.hmr('Reload generated pages.')\n    this._server.ws.send({\n      type: 'full-reload',\n    })\n  }\n\n  async resolveRoutes() {\n    return this.options.resolver.resolveRoutes(this)\n  }\n\n  async searchGlob() {\n    const pageDirFiles = this.options.dirs.map((page) => {\n      const pagesDirPath = slash(resolve(this.options.root, page.dir))\n      const files = getPageFiles(pagesDirPath, this.options)\n      debug.search(page.dir, files)\n      return {\n        ...page,\n        files: files.map(file => slash(file)),\n      }\n    })\n\n    for (const page of pageDirFiles)\n      await this.addPage(page.files, page)\n\n    debug.cache(this.pageRouteMap)\n  }\n\n  get debug() {\n    return debug\n  }\n\n  get pageRouteMap() {\n    return this._pageRouteMap\n  }\n}\n","function clamp(n, min, max) {\n  return Math.min(max, Math.max(min, n));\n}\nfunction sum(...args) {\n  return flattenArrayable(args).reduce((a, b) => a + b, 0);\n}\n\nfunction toArray(array) {\n  array = array || [];\n  if (Array.isArray(array))\n    return array;\n  return [array];\n}\nfunction flattenArrayable(array) {\n  return toArray(array).flat(1);\n}\nfunction mergeArrayable(...args) {\n  return args.flatMap((i) => toArray(i));\n}\nfunction partition(array, ...filters) {\n  const result = new Array(filters.length + 1).fill(null).map(() => []);\n  array.forEach((e, idx, arr) => {\n    let i = 0;\n    for (const filter of filters) {\n      if (filter(e, idx, arr)) {\n        result[i].push(e);\n        return;\n      }\n      i += 1;\n    }\n    result[i].push(e);\n  });\n  return result;\n}\nfunction uniq(array) {\n  return Array.from(new Set(array));\n}\nfunction last(array) {\n  return at(array, -1);\n}\nfunction remove(array, value) {\n  if (!array)\n    return false;\n  const index = array.indexOf(value);\n  if (index >= 0) {\n    array.splice(index, 1);\n    return true;\n  }\n  return false;\n}\nfunction at(array, index) {\n  const len = array.length;\n  if (!len)\n    return void 0;\n  if (index < 0)\n    index += len;\n  return array[index];\n}\nfunction range(...args) {\n  let start, stop, step;\n  if (args.length === 1) {\n    start = 0;\n    step = 1;\n    [stop] = args;\n  } else {\n    [start, stop, step = 1] = args;\n  }\n  const arr = [];\n  let current = start;\n  while (current < stop) {\n    arr.push(current);\n    current += step || 1;\n  }\n  return arr;\n}\nfunction move(arr, from, to) {\n  arr.splice(to, 0, arr.splice(from, 1)[0]);\n  return arr;\n}\nfunction clampArrayRange(n, arr) {\n  return clamp(n, 0, arr.length - 1);\n}\nfunction sample(arr, count) {\n  return Array.from({ length: count }, (_) => arr[Math.round(Math.random() * (arr.length - 1))]);\n}\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n}\n\nconst assert = (condition, message) => {\n  if (!condition)\n    throw new Error(message);\n};\nconst toString = (v) => Object.prototype.toString.call(v);\nconst noop = () => {\n};\n\nfunction notNullish(v) {\n  return v != null;\n}\nfunction noNull(v) {\n  return v !== null;\n}\nfunction notUndefined(v) {\n  return v !== void 0;\n}\nfunction isTruthy(v) {\n  return Boolean(v);\n}\n\nconst isDef = (val) => typeof val !== \"undefined\";\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString(val) === \"[object Window]\";\nconst isBrowser = typeof window !== \"undefined\";\n\nfunction slash(str) {\n  return str.replace(/\\\\/g, \"/\");\n}\nfunction ensurePrefix(prefix, str) {\n  if (!str.startsWith(prefix))\n    return prefix + str;\n  return str;\n}\nfunction ensureSuffix(suffix, str) {\n  if (!str.endsWith(suffix))\n    return str + suffix;\n  return str;\n}\nfunction template(str, ...args) {\n  return str.replace(/{(\\d+)}/g, (match, key) => {\n    const index = Number(key);\n    if (Number.isNaN(index))\n      return match;\n    return args[index];\n  });\n}\nconst urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nfunction randomStr(size = 16, dict = urlAlphabet) {\n  let id = \"\";\n  let i = size;\n  const len = dict.length;\n  while (i--)\n    id += dict[Math.random() * len | 0];\n  return id;\n}\n\nconst timestamp = () => +Date.now();\n\nfunction batchInvoke(functions) {\n  functions.forEach((fn) => fn && fn());\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction tap(value, callback) {\n  callback(value);\n  return value;\n}\n\nfunction objectMap(obj, fn) {\n  return Object.fromEntries(Object.entries(obj).map(([k, v]) => fn(k, v)).filter(notNullish));\n}\nfunction isKeyOf(obj, k) {\n  return k in obj;\n}\nfunction objectKeys(obj) {\n  return Object.keys(obj);\n}\nfunction objectEntries(obj) {\n  return Object.entries(obj);\n}\nfunction deepMerge(target, ...sources) {\n  if (!sources.length)\n    return target;\n  const source = sources.shift();\n  if (source === void 0)\n    return target;\n  if (isMergableObject(target) && isMergableObject(source)) {\n    objectKeys(source).forEach((key) => {\n      if (isMergableObject(source[key])) {\n        if (!target[key])\n          target[key] = {};\n        deepMerge(target[key], source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    });\n  }\n  return deepMerge(target, ...sources);\n}\nfunction isMergableObject(item) {\n  return isObject(item) && !Array.isArray(item);\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\nfunction clearUndefined(obj) {\n  Object.keys(obj).forEach((key) => obj[key] === void 0 ? delete obj[key] : {});\n  return obj;\n}\nfunction hasOwnProperty(obj, v) {\n  if (obj == null)\n    return false;\n  return Object.prototype.hasOwnProperty.call(obj, v);\n}\n\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction sleep(ms, callback) {\n  return new Promise((resolve) => setTimeout(async () => {\n    await (callback == null ? void 0 : callback());\n    resolve();\n  }, ms));\n}\nfunction createPromiseLock() {\n  const locks = [];\n  return {\n    async run(fn) {\n      const p = fn();\n      locks.push(p);\n      try {\n        return await p;\n      } finally {\n        remove(locks, p);\n      }\n    },\n    async wait() {\n      await Promise.allSettled(locks);\n    },\n    isWaiting() {\n      return Boolean(locks.length);\n    },\n    clear() {\n      locks.length = 0;\n    }\n  };\n}\nfunction createControlledPromise() {\n  let resolve, reject;\n  const promise = new Promise((_resolve, _reject) => {\n    resolve = _resolve;\n    reject = _reject;\n  });\n  promise.resolve = resolve;\n  promise.reject = reject;\n  return promise;\n}\n\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\n *                                    the internal counter is reset).\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                    to `callback` when the throttled-function is executed.\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\n *                                    schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function}  A new, throttled, function.\n */\nfunction throttle (delay, noTrailing, callback, debounceMode) {\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel() {\n    clearExistingTimeout();\n    cancelled = true;\n  } // `noTrailing` defaults to falsy.\n\n\n  if (typeof noTrailing !== 'boolean') {\n    debounceMode = callback;\n    callback = noTrailing;\n    noTrailing = undefined;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      /*\n       * In throttle mode, if `delay` time has been exceeded, execute\n       * `callback`.\n       */\n      exec();\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                  to `callback` when the debounced-function is executed.\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, atBegin, callback) {\n  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\n}\n\n/*\nHow it works:\n`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.\n*/\n\nclass Node {\n\tvalue;\n\tnext;\n\n\tconstructor(value) {\n\t\tthis.value = value;\n\t}\n}\n\nclass Queue {\n\t#head;\n\t#tail;\n\t#size;\n\n\tconstructor() {\n\t\tthis.clear();\n\t}\n\n\tenqueue(value) {\n\t\tconst node = new Node(value);\n\n\t\tif (this.#head) {\n\t\t\tthis.#tail.next = node;\n\t\t\tthis.#tail = node;\n\t\t} else {\n\t\t\tthis.#head = node;\n\t\t\tthis.#tail = node;\n\t\t}\n\n\t\tthis.#size++;\n\t}\n\n\tdequeue() {\n\t\tconst current = this.#head;\n\t\tif (!current) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.#head = this.#head.next;\n\t\tthis.#size--;\n\t\treturn current.value;\n\t}\n\n\tclear() {\n\t\tthis.#head = undefined;\n\t\tthis.#tail = undefined;\n\t\tthis.#size = 0;\n\t}\n\n\tget size() {\n\t\treturn this.#size;\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tlet current = this.#head;\n\n\t\twhile (current) {\n\t\t\tyield current.value;\n\t\t\tcurrent = current.next;\n\t\t}\n\t}\n}\n\nfunction pLimit(concurrency) {\n\tif (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {\n\t\tthrow new TypeError('Expected `concurrency` to be a number from 1 and up');\n\t}\n\n\tconst queue = new Queue();\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.size > 0) {\n\t\t\tqueue.dequeue()();\n\t\t}\n\t};\n\n\tconst run = async (fn, resolve, args) => {\n\t\tactiveCount++;\n\n\t\tconst result = (async () => fn(...args))();\n\n\t\tresolve(result);\n\n\t\ttry {\n\t\t\tawait result;\n\t\t} catch {}\n\n\t\tnext();\n\t};\n\n\tconst enqueue = (fn, resolve, args) => {\n\t\tqueue.enqueue(run.bind(undefined, fn, resolve, args));\n\n\t\t(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// when the run function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve();\n\n\t\t\tif (activeCount < concurrency && queue.size > 0) {\n\t\t\t\tqueue.dequeue()();\n\t\t\t}\n\t\t})();\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => {\n\t\tenqueue(fn, resolve, args);\n\t});\n\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount,\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.size,\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.clear();\n\t\t\t},\n\t\t},\n\t});\n\n\treturn generator;\n}\n\nconst VOID = Symbol(\"p-void\");\nclass PInstance extends Promise {\n  constructor(items = [], options) {\n    super(() => {\n    });\n    this.items = items;\n    this.options = options;\n    this.promises = /* @__PURE__ */ new Set();\n  }\n  get promise() {\n    var _a;\n    let batch;\n    const items = [...Array.from(this.items), ...Array.from(this.promises)];\n    if ((_a = this.options) == null ? void 0 : _a.concurrency) {\n      const limit = pLimit(this.options.concurrency);\n      batch = Promise.all(items.map((p2) => limit(() => p2)));\n    } else {\n      batch = Promise.all(items);\n    }\n    return batch.then((l) => l.filter((i) => i !== VOID));\n  }\n  add(...args) {\n    args.forEach((i) => {\n      this.promises.add(i);\n    });\n  }\n  map(fn) {\n    return new PInstance(Array.from(this.items).map(async (i, idx) => {\n      const v = await i;\n      if (v === VOID)\n        return VOID;\n      return fn(v, idx);\n    }), this.options);\n  }\n  filter(fn) {\n    return new PInstance(Array.from(this.items).map(async (i, idx) => {\n      const v = await i;\n      const r = await fn(v, idx);\n      if (!r)\n        return VOID;\n      return v;\n    }), this.options);\n  }\n  forEach(fn) {\n    return this.map(fn).then();\n  }\n  reduce(fn, initialValue) {\n    return this.promise.then((array) => array.reduce(fn, initialValue));\n  }\n  clear() {\n    this.promises.clear();\n  }\n  then(fn) {\n    const p2 = this.promise;\n    if (fn)\n      return p2.then(fn);\n    else\n      return p2;\n  }\n  catch(fn) {\n    return this.promise.catch(fn);\n  }\n  finally(fn) {\n    return this.promise.finally(fn);\n  }\n}\nfunction p(items, options) {\n  return new PInstance(items, options);\n}\n\nexport { assert, at, batchInvoke, clamp, clampArrayRange, clearUndefined, createControlledPromise, createPromiseLock, createSingletonPromise, debounce, deepMerge, ensurePrefix, ensureSuffix, flattenArrayable, hasOwnProperty, invoke, isBoolean, isBrowser, isDef, isFunction, isKeyOf, isNumber, isObject, isString, isTruthy, isWindow, last, mergeArrayable, move, noNull, noop, notNullish, notUndefined, objectEntries, objectKeys, objectMap, objectPick, p, partition, randomStr, range, remove, sample, shuffle, slash, sleep, sum, tap, template, throttle, timestamp, toArray, toString, uniq };\n","import { resolve } from 'path'\nimport { slash, toArray } from '@antfu/utils'\nimport { getPageDirs } from './files'\n\nimport { reactResolver, solidResolver, vueResolver } from './resolvers'\nimport { MODULE_IDS } from './constants'\nimport type { ImportModeResolver, ResolvedOptions, UserOptions } from './types'\n\nfunction resolvePageDirs(dirs: UserOptions['dirs'], root: string, exclude: string[]) {\n  dirs = toArray(dirs)\n  return dirs.flatMap((dir) => {\n    const option = typeof dir === 'string'\n      ? { dir, baseRoute: '' }\n      : dir\n\n    option.dir = slash(resolve(root, option.dir)).replace(`${root}/`, '')\n    option.baseRoute = option.baseRoute.replace(/^\\//, '').replace(/\\/$/, '')\n\n    return getPageDirs(option, root, exclude)\n  })\n}\n\nexport const syncIndexResolver: ImportModeResolver = (filepath, options) => {\n  for (const page of options.dirs) {\n    if (page.baseRoute === '' && filepath.startsWith(`/${page.dir}/index`))\n      return 'sync'\n  }\n  return 'async'\n}\n\nconst getResolver = (originalResolver: UserOptions['resolver']) => {\n  let resolver = originalResolver || 'vue'\n\n  if (typeof resolver !== 'string')\n    return resolver\n\n  switch (resolver) {\n    case 'vue':\n      resolver = vueResolver()\n      break\n    case 'react':\n      resolver = reactResolver()\n      break\n    case 'solid':\n      resolver = solidResolver()\n      break\n    default:\n      throw new Error(`Unsupported resolver: ${resolver}`)\n  }\n  return resolver\n}\n\nexport function resolveOptions(userOptions: UserOptions, viteRoot?: string): ResolvedOptions {\n  const {\n    dirs = userOptions.pagesDir || ['src/pages'],\n    routeBlockLang = 'json5',\n    exclude = ['node_modules', '.git', '**/__*__/**'],\n    caseSensitive = false,\n    syncIndex = true,\n    routeNameSeparator = '-',\n    extendRoute,\n    onRoutesGenerated,\n    onClientGenerated,\n  } = userOptions\n\n  const root = viteRoot || slash(process.cwd())\n\n  const importMode = userOptions.importMode || (syncIndex ? syncIndexResolver : 'async')\n\n  const resolver = getResolver(userOptions.resolver)\n\n  const extensions = userOptions.extensions || resolver.resolveExtensions()\n\n  const extensionsRE = new RegExp(`\\\\.(${extensions.join('|')})$`)\n\n  const resolvedDirs = resolvePageDirs(dirs, root, exclude)\n\n  const routeStyle = userOptions.nuxtStyle ? 'nuxt' : userOptions.routeStyle || 'next'\n\n  const moduleIds = userOptions.moduleId\n    ? [userOptions.moduleId]\n    : resolver.resolveModuleIds?.() || MODULE_IDS\n\n  const resolvedOptions: ResolvedOptions = {\n    dirs: resolvedDirs,\n    routeStyle,\n    routeBlockLang,\n    moduleIds,\n    root,\n    extensions,\n    importMode,\n    exclude,\n    caseSensitive,\n    resolver,\n    extensionsRE,\n    extendRoute,\n    onRoutesGenerated,\n    onClientGenerated,\n    routeNameSeparator,\n  }\n\n  return resolvedOptions\n}\n","import { join } from 'path'\nimport { slash } from '@antfu/utils'\nimport fg from 'fast-glob'\nimport { extsToGlob } from './utils'\n\nimport type { PageOptions, ResolvedOptions } from './types'\n\n/**\n * Resolves the page dirs for its for its given globs\n */\nexport function getPageDirs(PageOptions: PageOptions, root: string, exclude: string[]): PageOptions[] {\n  const dirs = fg.sync(slash(PageOptions.dir), {\n    ignore: exclude,\n    onlyDirectories: true,\n    dot: true,\n    unique: true,\n    cwd: root,\n  })\n\n  const pageDirs = dirs.map(dir => ({\n    ...PageOptions,\n    dir,\n  }))\n\n  return pageDirs\n}\n\n/**\n * Resolves the files that are valid pages for the given context.\n */\nexport function getPageFiles(path: string, options: ResolvedOptions): string[] {\n  const {\n    exclude,\n    extensions,\n  } = options\n\n  const ext = extsToGlob(extensions)\n\n  const files = fg.sync(slash(join(path, `**/*.${ext}`)), {\n    ignore: exclude,\n    onlyFiles: true,\n  })\n\n  return files\n}\n","import { resolve, win32 } from 'path'\nimport { URLSearchParams } from 'url'\nimport Debug from 'debug'\nimport { slash } from '@antfu/utils'\nimport { MODULE_ID_VIRTUAL, cacheAllRouteRE, countSlashRE, dynamicRouteRE, nuxtCacheAllRouteRE, nuxtDynamicRouteRE, replaceDynamicRouteRE, replaceIndexRE } from './constants'\n\nimport type { ModuleNode, ViteDevServer } from 'vite'\nimport type { ResolvedOptions } from './types'\n\nexport const debug = {\n  hmr: Debug('vite-plugin-pages:hmr'),\n  routeBlock: Debug('vite-plugin-pages:routeBlock'),\n  options: Debug('vite-plugin-pages:options'),\n  pages: Debug('vite-plugin-pages:pages'),\n  search: Debug('vite-plugin-pages:search'),\n  env: Debug('vite-plugin-pages:env'),\n  cache: Debug('vite-plugin-pages:cache'),\n  resolver: Debug('vite-plugin-pages:resolver'),\n}\n\nexport function extsToGlob(extensions: string[]) {\n  return extensions.length > 1 ? `{${extensions.join(',')}}` : extensions[0] || ''\n}\n\nexport function countSlash(value: string) {\n  return (value.match(countSlashRE) || []).length\n}\n\nfunction isPagesDir(path: string, options: ResolvedOptions) {\n  for (const page of options.dirs) {\n    const dirPath = slash(resolve(options.root, page.dir))\n    if (path.startsWith(dirPath)) return true\n  }\n  return false\n}\n\nexport function isTarget(path: string, options: ResolvedOptions) {\n  return isPagesDir(path, options) && options.extensionsRE.test(path)\n}\n\nexport function isDynamicRoute(routePath: string, nuxtStyle = false) {\n  return nuxtStyle\n    ? nuxtDynamicRouteRE.test(routePath)\n    : dynamicRouteRE.test(routePath)\n}\n\nexport function isCatchAllRoute(routePath: string, nuxtStyle = false) {\n  return nuxtStyle\n    ? nuxtCacheAllRouteRE.test(routePath)\n    : cacheAllRouteRE.test(routePath)\n}\n\nexport function resolveImportMode(\n  filepath: string,\n  options: ResolvedOptions,\n) {\n  const mode = options.importMode\n  if (typeof mode === 'function')\n    return mode(filepath, options)\n  return mode\n}\n\nexport function invalidatePagesModule(server: ViteDevServer) {\n  const { moduleGraph } = server\n  const mods = moduleGraph.getModulesByFile(MODULE_ID_VIRTUAL)\n  if (mods) {\n    const seen = new Set<ModuleNode>()\n    mods.forEach((mod) => {\n      moduleGraph.invalidateModule(mod, seen)\n    })\n  }\n}\n\nexport function normalizeCase(str: string, caseSensitive: boolean) {\n  if (!caseSensitive) return str.toLocaleLowerCase()\n  return str\n}\n\nexport function normalizeName(name: string, isDynamic: boolean, nuxtStyle = false) {\n  if (!isDynamic) return name\n\n  return nuxtStyle\n    ? name.replace(nuxtDynamicRouteRE, '$1') || 'all'\n    : name.replace(replaceDynamicRouteRE, '$1')\n}\n\nexport function buildReactRoutePath(node: string, nuxtStyle = false): string | undefined {\n  const isDynamic = isDynamicRoute(node, nuxtStyle)\n  const isCatchAll = isCatchAllRoute(node, nuxtStyle)\n  const normalizedName = normalizeName(node, isDynamic, nuxtStyle)\n\n  if (isDynamic) {\n    if (isCatchAll)\n      return '*'\n\n    return `:${normalizedName}`\n  }\n\n  return `${normalizedName}`\n}\n\n// https://github.dev/remix-run/remix/blob/264e3f8884c5cafd8d06acc3e01153b376745b7c/packages/remix-dev/config/routesConvention.ts#L105\nexport function buildReactRemixRoutePath(node: string): string | undefined {\n  const escapeStart = '['\n  const escapeEnd = ']'\n  let result = ''\n  let rawSegmentBuffer = ''\n\n  let inEscapeSequence = 0\n  let skipSegment = false\n  for (let i = 0; i < node.length; i++) {\n    const char = node.charAt(i)\n    const lastChar = i > 0 ? node.charAt(i - 1) : undefined\n    const nextChar = i < node.length - 1 ? node.charAt(i + 1) : undefined\n\n    function isNewEscapeSequence() {\n      return (\n        !inEscapeSequence && char === escapeStart && lastChar !== escapeStart\n      )\n    }\n\n    function isCloseEscapeSequence() {\n      return inEscapeSequence && char === escapeEnd && nextChar !== escapeEnd\n    }\n\n    function isStartOfLayoutSegment() {\n      return char === '_' && nextChar === '_' && !rawSegmentBuffer\n    }\n\n    if (skipSegment) {\n      if (char === '/' || char === '.' || char === win32.sep)\n        skipSegment = false\n\n      continue\n    }\n\n    if (isNewEscapeSequence()) {\n      inEscapeSequence++\n      continue\n    }\n\n    if (isCloseEscapeSequence()) {\n      inEscapeSequence--\n      continue\n    }\n\n    if (inEscapeSequence) {\n      result += char\n      continue\n    }\n\n    if (char === '/' || char === win32.sep || char === '.') {\n      if (rawSegmentBuffer === 'index' && result.endsWith('index'))\n        result = result.replace(replaceIndexRE, '')\n      else result += '/'\n\n      rawSegmentBuffer = ''\n      continue\n    }\n\n    if (isStartOfLayoutSegment()) {\n      skipSegment = true\n      continue\n    }\n\n    rawSegmentBuffer += char\n\n    if (char === '$') {\n      result += typeof nextChar === 'undefined' ? '*' : ':'\n      continue\n    }\n\n    result += char\n  }\n\n  if (rawSegmentBuffer === 'index' && result.endsWith('index'))\n    result = result.replace(replaceIndexRE, '')\n\n  return result || undefined\n}\n\nexport function parsePageRequest(id: string) {\n  const [moduleId, rawQuery] = id.split('?', 2)\n  const query = new URLSearchParams(rawQuery)\n  const pageId = query.get('id')\n  return {\n    moduleId,\n    query,\n    pageId,\n  }\n}\n","import colors from 'picocolors'\nimport deepEqual from 'deep-equal'\nimport {\n  countSlash,\n  isCatchAllRoute,\n  isDynamicRoute,\n  normalizeCase,\n  normalizeName,\n} from '../utils'\nimport { generateClientCode } from '../stringify'\n\nimport { getRouteBlock } from '../customBlock'\nimport type { CustomBlock, Optional, PageResolver } from '../types'\nimport type { PageContext } from '../context'\n\nexport interface VueRouteBase {\n  name: string\n  path: string\n  props?: boolean\n  component: string\n  children?: VueRouteBase[]\n  customBlock?: CustomBlock\n  rawRoute: string\n}\n\nexport interface VueRoute extends Omit<Optional<VueRouteBase, 'rawRoute' | 'name'>, 'children'> {\n  children?: VueRoute[]\n}\n\nfunction prepareRoutes(\n  ctx: PageContext,\n  routes: VueRoute[],\n  parent?: VueRoute,\n) {\n  for (const route of routes) {\n    if (route.name)\n      route.name = route.name.replace(/-index$/, '')\n\n    if (parent)\n      route.path = route.path?.replace(/^\\//, '')\n\n    if (route.children)\n      route.children = prepareRoutes(ctx, route.children, route)\n\n    if (route.children?.find(c => c.name === route.name))\n      delete route.name\n\n    route.props = true\n\n    delete route.rawRoute\n\n    if (route.customBlock) {\n      Object.assign(route, route.customBlock || {})\n      delete route.customBlock\n    }\n\n    Object.assign(route, ctx.options.extendRoute?.(route, parent) || {})\n  }\n\n  return routes\n}\n\nasync function computeVueRoutes(ctx: PageContext, customBlockMap: Map<string, CustomBlock>): Promise<VueRoute[]> {\n  const { routeStyle, caseSensitive, routeNameSeparator } = ctx.options\n\n  const pageRoutes = [...ctx.pageRouteMap.values()]\n    // sort routes for HMR\n    .sort((a, b) => countSlash(a.route) - countSlash(b.route))\n\n  const routes: VueRouteBase[] = []\n\n  pageRoutes.forEach((page) => {\n    const pathNodes = page.route.split('/')\n\n    // add leading slash to component path if not already there\n    const component = page.path.replace(ctx.root, '')\n    const customBlock = customBlockMap.get(page.path)\n\n    const route: VueRouteBase = {\n      name: '',\n      path: '',\n      component,\n      customBlock,\n      rawRoute: page.route,\n    }\n\n    let parentRoutes = routes\n    let dynamicRoute = false\n\n    for (let i = 0; i < pathNodes.length; i++) {\n      const node = pathNodes[i]\n      const nuxtStyle = routeStyle === 'nuxt'\n      const isDynamic = isDynamicRoute(node, nuxtStyle)\n      const isCatchAll = isCatchAllRoute(node, nuxtStyle)\n      const normalizedName = normalizeName(node, isDynamic, nuxtStyle)\n      const normalizedPath = normalizeCase(normalizedName, caseSensitive)\n\n      if (isDynamic)\n        dynamicRoute = true\n\n      route.name += route.name ? `${routeNameSeparator}${normalizedName}` : normalizedName\n\n      // Check parent exits\n      const parent = parentRoutes.find((parent) => {\n        return pathNodes.slice(0, i + 1).join('/') === parent.rawRoute\n      })\n\n      if (parent) {\n        // Make sure children exist in parent\n        parent.children = parent.children || []\n        // Append to parent's children\n        parentRoutes = parent.children\n        // Reset path\n        route.path = ''\n      } else if (normalizedPath === 'index') {\n        if (!route.path)\n          route.path = '/'\n      } else if (normalizedPath !== 'index') {\n        if (isDynamic) {\n          route.path += `/:${normalizedName}`\n          // Catch-all route\n          if (isCatchAll) {\n            if (i === 0)\n              // root cache all route include children\n              route.path += '(.*)*'\n            else\n              // nested cache all route not include children\n              route.path += '(.*)'\n          } else if (nuxtStyle && i === pathNodes.length - 1) {\n            // we need to search if the folder provide `index.vue`\n            const isIndexFound = pageRoutes.find(({ route }) => {\n              return route === page.route.replace(pathNodes[i], 'index')\n            })\n            if (!isIndexFound) route.path += '?'\n          }\n        } else {\n          route.path += `/${normalizedPath}`\n        }\n      }\n    }\n\n    // put dynamic routes at the end\n    if (dynamicRoute)\n      parentRoutes.push(route)\n    else\n      parentRoutes.unshift(route)\n  })\n\n  let finalRoutes = prepareRoutes(ctx, routes)\n\n  finalRoutes = (await ctx.options.onRoutesGenerated?.(finalRoutes)) || finalRoutes\n\n  return finalRoutes\n}\n\nasync function resolveVueRoutes(ctx: PageContext, customBlockMap: Map<string, CustomBlock>) {\n  const finalRoutes = await computeVueRoutes(ctx, customBlockMap)\n\n  let client = generateClientCode(finalRoutes, ctx.options)\n  client = (await ctx.options.onClientGenerated?.(client)) || client\n  return client\n}\n\nexport function vueResolver(): PageResolver {\n  const customBlockMap = new Map<string, CustomBlock>()\n\n  async function checkCustomBlockChange(ctx: PageContext, path: string) {\n    const exitsCustomBlock = customBlockMap.get(path)\n    let customBlock: CustomBlock | undefined\n    try {\n      customBlock = await getRouteBlock(path, ctx.options)\n    } catch (error: any) {\n      ctx.logger?.error(colors.red(`[vite-plugin-pages] ${error.message}`))\n      return\n    }\n    if (!exitsCustomBlock && !customBlock)\n      return\n\n    if (!customBlock) {\n      customBlockMap.delete(path)\n      ctx.debug.routeBlock('%s deleted', path)\n      return\n    }\n    if (!exitsCustomBlock || !deepEqual(exitsCustomBlock, customBlock)) {\n      ctx.debug.routeBlock('%s old: %O', path, exitsCustomBlock)\n      ctx.debug.routeBlock('%s new: %O', path, customBlock)\n      customBlockMap.set(path, customBlock)\n      ctx.onUpdate()\n    }\n  }\n\n  return {\n    resolveExtensions() {\n      return ['vue', 'ts', 'js']\n    },\n    resolveModuleIds() {\n      return ['~pages', 'pages-generated', 'virtual:generated-pages']\n    },\n    async resolveRoutes(ctx) {\n      return resolveVueRoutes(ctx, customBlockMap)\n    },\n    async getComputedRoutes(ctx) {\n      return computeVueRoutes(ctx, customBlockMap)\n    },\n    hmr: {\n      added: async(ctx, path) => checkCustomBlockChange(ctx, path),\n      changed: async(ctx, path) => checkCustomBlockChange(ctx, path),\n      removed: async(_ctx, path) => {\n        customBlockMap.delete(path)\n      },\n    },\n  }\n}\n","import { resolveImportMode } from './utils'\nimport { ROUTE_IMPORT_NAME } from './constants'\n\nimport type { ResolvedOptions } from './types'\n\nconst componentRE = /\"(?:component|element)\":(\"(.*?)\")/g\nconst hasFunctionRE = /\"(?:props|beforeEnter)\":(\"(.*?)\")/g\n\nconst multilineCommentsRE = /\\/\\*(.|[\\r\\n])*?\\*\\//gm\nconst singlelineCommentsRE = /\\/\\/.*/g\n\nfunction replaceFunction(_: any, value: any) {\n  if (value instanceof Function || typeof value === 'function') {\n    const fnBody = value.toString()\n      .replace(multilineCommentsRE, '')\n      .replace(singlelineCommentsRE, '')\n      .replace(/(\\t|\\n|\\r|\\s)/g, '')\n\n    // ES6 Arrow Function\n    if (fnBody.length < 8 || fnBody.substring(0, 8) !== 'function')\n      return `_NuFrRa_${fnBody}`\n\n    return fnBody\n  }\n\n  return value\n}\n\n/**\n * Creates a stringified Vue Router route definition.\n */\nexport function stringifyRoutes(\n  preparedRoutes: any[],\n  options: ResolvedOptions,\n) {\n  const importsMap: Map<string, string> = new Map()\n\n  function getImportString(path: string, importName: string) {\n    const mode = resolveImportMode(path, options)\n    return mode === 'sync'\n      ? `import ${importName} from \"${path}\"`\n      : `const ${importName} = ${\n        options.resolver.stringify?.dynamicImport?.(path) || `() => import(\"${path}\")`\n      }`\n  }\n\n  function componentReplacer(str: string, replaceStr: string, path: string) {\n    let importName = importsMap.get(path)\n\n    if (!importName)\n      importName = ROUTE_IMPORT_NAME.replace('$1', `${importsMap.size}`)\n\n    importsMap.set(path, importName)\n\n    importName = options.resolver.stringify?.component?.(importName) || importName\n\n    return str.replace(replaceStr, importName)\n  }\n\n  function functionReplacer(str: string, replaceStr: string, content: string) {\n    if (content.startsWith('function'))\n      return str.replace(replaceStr, content)\n\n    if (content.startsWith('_NuFrRa_'))\n      return str.replace(replaceStr, content.slice(8))\n\n    return str\n  }\n\n  const stringRoutes = JSON\n    .stringify(preparedRoutes, replaceFunction)\n    .replace(componentRE, componentReplacer)\n    .replace(hasFunctionRE, functionReplacer)\n\n  const imports = Array.from(importsMap).map(args => getImportString(...args))\n\n  return {\n    imports,\n    stringRoutes,\n  }\n}\n\nexport function generateClientCode(routes: any[], options: ResolvedOptions) {\n  const { imports, stringRoutes } = stringifyRoutes(routes, options)\n  const code = `${imports.join(';\\n')};\\n\\nconst routes = ${stringRoutes};\\n\\nexport default routes;`\n  return options.resolver.stringify?.final?.(code) || code\n}\n","import fs from 'fs'\nimport JSON5 from 'json5'\nimport { parse as YAMLParser } from 'yaml'\n\nimport { importModule } from 'local-pkg'\n\n// @ts-expect-error no type\nimport extractComments from 'extract-comments'\nimport { debug } from './utils'\nimport type { SFCBlock, SFCDescriptor } from '@vue/compiler-sfc'\nimport type { CustomBlock, ParsedJSX, ResolvedOptions } from './types'\n\nconst routeJSXReg = /^[\\n\\s]+(route)[\\n\\s]+/gm\n\nexport function parseJSX(code: string): ParsedJSX[] {\n  return extractComments(code).slice(0, 1)\n    .filter((comment: ParsedJSX) => routeJSXReg.test(comment.value) && comment.value.includes(':') && comment.loc.start.line === 1)\n}\n\nexport function parseYamlComment(code: ParsedJSX[], path: string): CustomBlock {\n  return code.reduce((memo, item) => {\n    const { value } = item\n    const v = value.replace(routeJSXReg, '')\n    debug.routeBlock(`use ${v} parser`)\n    try {\n      const yamlResult = YAMLParser(v)\n\n      return {\n        ...memo,\n        ...yamlResult,\n      }\n    } catch (err: any) {\n      throw new Error(`Invalid YAML format of comment in ${path}\\n${err.message}`)\n    }\n  }, {})\n}\n\nexport async function parseSFC(code: string): Promise<SFCDescriptor> {\n  try {\n    const { parse } = await importModule('@vue/compiler-sfc') as typeof import('@vue/compiler-sfc')\n    return parse(code, {\n      pad: 'space',\n    }).descriptor\n  } catch {\n    throw new Error('[vite-plugin-pages] Vue3\\'s \"@vue/compiler-sfc\" is required.')\n  }\n}\n\nexport function parseCustomBlock(block: SFCBlock, filePath: string, options: ResolvedOptions): any {\n  const lang = block.lang ?? options.routeBlockLang\n\n  debug.routeBlock(`use ${lang} parser`)\n\n  if (lang === 'json5') {\n    try {\n      return JSON5.parse(block.content)\n    } catch (err: any) {\n      throw new Error(`Invalid JSON5 format of <${block.type}> content in ${filePath}\\n${err.message}`)\n    }\n  } else if (lang === 'json') {\n    try {\n      return JSON.parse(block.content)\n    } catch (err: any) {\n      throw new Error(`Invalid JSON format of <${block.type}> content in ${filePath}\\n${err.message}`)\n    }\n  } else if (lang === 'yaml' || lang === 'yml') {\n    try {\n      return YAMLParser(block.content)\n    } catch (err: any) {\n      throw new Error(`Invalid YAML format of <${block.type}> content in ${filePath}\\n${err.message}`)\n    }\n  }\n}\n\nexport async function getRouteBlock(path: string, options: ResolvedOptions) {\n  const content = fs.readFileSync(path, 'utf8')\n\n  const parsedSFC = await parseSFC(content)\n  const blockStr = parsedSFC?.customBlocks.find(b => b.type === 'route')\n\n  const parsedJSX = parseJSX(content)\n\n  if (!blockStr && parsedJSX.length === 0)\n    return\n\n  let result\n\n  if (blockStr)\n    result = parseCustomBlock(blockStr, path, options) as CustomBlock\n\n  if (parsedJSX.length > 0)\n    result = parseYamlComment(parsedJSX, path) as CustomBlock\n\n  return result\n}\n","import {\n  buildReactRemixRoutePath,\n  buildReactRoutePath,\n  countSlash,\n  normalizeCase,\n} from '../utils'\nimport { generateClientCode } from '../stringify'\n\nimport type { Optional, PageResolver, ResolvedOptions } from '../types'\nimport type { PageContext } from '../context'\n\nexport interface ReactRouteBase {\n  caseSensitive?: boolean\n  children?: ReactRouteBase[]\n  element?: string\n  index?: boolean\n  path?: string\n  rawRoute: string\n}\n\nexport interface ReactRoute extends Omit<Optional<ReactRouteBase, 'rawRoute' | 'path'>, 'children'> {\n  children?: ReactRoute[]\n}\n\nfunction prepareRoutes(\n  routes: ReactRoute[],\n  options: ResolvedOptions,\n  parent?: ReactRoute,\n) {\n  for (const route of routes) {\n    if (parent)\n      route.path = route.path?.replace(/^\\//, '')\n\n    if (route.children)\n      route.children = prepareRoutes(route.children, options, route)\n\n    delete route.rawRoute\n\n    Object.assign(route, options.extendRoute?.(route, parent) || {})\n  }\n\n  return routes\n}\n\nasync function computeReactRoutes(ctx: PageContext): Promise<ReactRoute[]> {\n  const { routeStyle, caseSensitive } = ctx.options\n  const nuxtStyle = routeStyle === 'nuxt'\n\n  const pageRoutes = [...ctx.pageRouteMap.values()]\n    // sort routes for HMR\n    .sort((a, b) => countSlash(a.route) - countSlash(b.route))\n\n  const routes: ReactRouteBase[] = []\n\n  pageRoutes.forEach((page) => {\n    const pathNodes = page.route.split('/')\n    const element = page.path.replace(ctx.root, '')\n    let parentRoutes = routes\n\n    for (let i = 0; i < pathNodes.length; i++) {\n      const node = pathNodes[i]\n\n      const route: ReactRouteBase = {\n        caseSensitive,\n        path: '',\n        rawRoute: pathNodes.slice(0, i + 1).join('/'),\n      }\n\n      if (i === pathNodes.length - 1) route.element = element\n\n      const isIndexRoute = normalizeCase(node, caseSensitive).endsWith('index')\n\n      if (!route.path && isIndexRoute) {\n        route.path = '/'\n      } else if (!isIndexRoute) {\n        if (routeStyle === 'remix')\n          route.path = buildReactRemixRoutePath(node)\n        else\n          route.path = buildReactRoutePath(node, nuxtStyle)\n      }\n\n      // Check parent exits\n      const parent = parentRoutes.find((parent) => {\n        return pathNodes.slice(0, i).join('/') === parent.rawRoute\n      })\n\n      if (parent) {\n        // Make sure children exits in parent\n        parent.children = parent.children || []\n        // Append to parent's children\n        parentRoutes = parent.children\n      }\n\n      const exits = parentRoutes.some((parent) => {\n        return pathNodes.slice(0, i + 1).join('/') === parent.rawRoute\n      })\n      if (!exits)\n        parentRoutes.push(route)\n    }\n  })\n\n  // sort by dynamic routes\n  let finalRoutes = prepareRoutes(routes, ctx.options)\n\n  finalRoutes = (await ctx.options.onRoutesGenerated?.(finalRoutes)) || finalRoutes\n\n  return finalRoutes\n}\n\nasync function resolveReactRoutes(ctx: PageContext) {\n  const finalRoutes = await computeReactRoutes(ctx)\n  let client = generateClientCode(finalRoutes, ctx.options)\n  client = (await ctx.options.onClientGenerated?.(client)) || client\n  return client\n}\n\nexport function reactResolver(): PageResolver {\n  return {\n    resolveModuleIds() {\n      return ['~react-pages', 'virtual:generated-pages-react']\n    },\n    resolveExtensions() {\n      return ['tsx', 'jsx', 'ts', 'js']\n    },\n    async resolveRoutes(ctx) {\n      return resolveReactRoutes(ctx)\n    },\n    async getComputedRoutes(ctx) {\n      return computeReactRoutes(ctx)\n    },\n    stringify: {\n      component: path => `React.createElement(${path})`,\n      dynamicImport: path => `React.lazy(() => import(\"${path}\"))`,\n      final: code => `import React from \"react\";\\n${code}`,\n    },\n  }\n}\n","import {\n  buildReactRemixRoutePath,\n  buildReactRoutePath,\n  countSlash,\n  normalizeCase,\n} from '../utils'\nimport { generateClientCode } from '../stringify'\n\nimport type { Optional, PageResolver, ResolvedOptions } from '../types'\nimport type { PageContext } from '../context'\n\nexport interface SolidRouteBase {\n  rawRoute: string\n  path: string\n  children?: SolidRouteBase[]\n  component?: string\n  element?: string\n}\n\nexport interface SolidRoute extends Omit<Optional<SolidRouteBase, 'rawRoute' | 'path'>, 'children'> {\n  children?: SolidRoute[]\n}\n\nfunction prepareRoutes(\n  options: ResolvedOptions,\n  routes: SolidRoute[],\n  parent?: SolidRoute,\n) {\n  for (const route of routes) {\n    if (parent)\n      route.path = route.path?.replace(/^\\//, '')\n\n    if (route.children)\n      route.children = prepareRoutes(options, route.children, route)\n\n    delete route.rawRoute\n\n    Object.assign(route, options.extendRoute?.(route, parent) || {})\n  }\n\n  return routes\n}\n\nasync function computeSolidRoutes(ctx: PageContext): Promise<SolidRoute[]> {\n  const { routeStyle, caseSensitive } = ctx.options\n  const nuxtStyle = routeStyle === 'nuxt'\n\n  const pageRoutes = [...ctx.pageRouteMap.values()]\n    // sort routes for HMR\n    .sort((a, b) => countSlash(a.route) - countSlash(b.route))\n\n  const routes: SolidRouteBase[] = []\n\n  pageRoutes.forEach((page) => {\n    const pathNodes = page.route.split('/')\n\n    const component = page.path.replace(ctx.root, '')\n    const element = page.path.replace(ctx.root, '')\n\n    let parentRoutes = routes\n\n    for (let i = 0; i < pathNodes.length; i++) {\n      const node = pathNodes[i]\n      const normalizedPath = normalizeCase(node, caseSensitive)\n\n      const route: SolidRouteBase = {\n        path: '',\n        rawRoute: pathNodes.slice(0, i + 1).join('/'),\n      }\n\n      // Check parent exists\n      const parent = parentRoutes.find(parent =>\n        pathNodes.slice(0, i).join('/') === parent.rawRoute,\n      )\n\n      if (parent) {\n        // Make sure children exist in parent\n        parent.children = parent.children || []\n        // Append to parent's children\n        parentRoutes = parent.children\n      }\n\n      if (i === pathNodes.length - 1) {\n        route.element = element\n        route.component = component\n      }\n\n      if (normalizedPath === 'index') {\n        if (!route.path)\n          route.path = '/'\n      } else if (normalizedPath !== 'index') {\n        if (routeStyle === 'remix')\n          route.path = buildReactRemixRoutePath(node) || ''\n        else\n          route.path = buildReactRoutePath(node, nuxtStyle) || ''\n      }\n\n      const exist = parentRoutes.some((parent) => {\n        return pathNodes.slice(0, i + 1).join('/') === parent.rawRoute\n      })\n      if (!exist)\n        parentRoutes.push(route)\n    }\n  })\n\n  // sort by dynamic routes\n  let finalRoutes = prepareRoutes(ctx.options, routes)\n\n  finalRoutes = (await ctx.options.onRoutesGenerated?.(finalRoutes)) || finalRoutes\n\n  return finalRoutes\n}\n\nasync function resolveSolidRoutes(ctx: PageContext) {\n  const finalRoutes = await computeSolidRoutes(ctx)\n  let client = generateClientCode(finalRoutes, ctx.options)\n  client = (await ctx.options.onClientGenerated?.(client)) || client\n  return client\n}\n\nexport function solidResolver(): PageResolver {\n  return {\n    resolveModuleIds() {\n      return ['~solid-pages']\n    },\n    resolveExtensions() {\n      return ['tsx', 'jsx', 'ts', 'js']\n    },\n    async resolveRoutes(ctx) {\n      return resolveSolidRoutes(ctx)\n    },\n    async getComputedRoutes(ctx) {\n      return computeSolidRoutes(ctx)\n    },\n    stringify: {\n      dynamicImport: path => `Solid.lazy(() => import(\"${path}\"))`,\n      final: code => `import * as Solid from \"solid-js\";\\n${code}`,\n    },\n  }\n}\n","import { MODULE_ID_VIRTUAL, ROUTE_BLOCK_ID_VIRTUAL, routeBlockQueryRE } from './constants'\nimport { PageContext } from './context'\n\nimport { parsePageRequest } from './utils'\nimport type { UserOptions } from './types'\nimport type { Plugin } from 'vite'\n\nfunction pagesPlugin(userOptions: UserOptions = {}): Plugin {\n  let ctx: PageContext\n\n  return {\n    name: 'vite-plugin-pages',\n    enforce: 'pre',\n    async configResolved(config) {\n      // auto set resolver for react project\n      if (\n        !userOptions.resolver\n        && config.plugins.find(i => i.name.includes('vite:react'))\n      )\n        userOptions.resolver = 'react'\n\n      // auto set resolver for solid project\n      if (\n        !userOptions.resolver\n        && config.plugins.find(i => i.name.includes('solid'))\n      )\n        userOptions.resolver = 'solid'\n\n      ctx = new PageContext(userOptions, config.root)\n      ctx.setLogger(config.logger)\n      await ctx.searchGlob()\n    },\n    api: {\n      getResolvedRoutes() {\n        return ctx.options.resolver.getComputedRoutes(ctx)\n      },\n    },\n    configureServer(server) {\n      ctx.setupViteServer(server)\n    },\n    resolveId(id) {\n      if (ctx.options.moduleIds.includes(id))\n        return `${MODULE_ID_VIRTUAL}?id=${id}`\n\n      if (routeBlockQueryRE.test(id))\n        return ROUTE_BLOCK_ID_VIRTUAL\n\n      return null\n    },\n    async load(id) {\n      const {\n        moduleId,\n        pageId,\n      } = parsePageRequest(id)\n\n      if (moduleId === MODULE_ID_VIRTUAL && pageId && ctx.options.moduleIds.includes(pageId))\n        return ctx.resolveRoutes()\n\n      if (id === ROUTE_BLOCK_ID_VIRTUAL) {\n        return {\n          code: 'export default {};',\n          map: null,\n        }\n      }\n\n      return null\n    },\n  }\n}\n\nexport * from './types'\nexport type {\n  VueRoute,\n  ReactRoute,\n  SolidRoute,\n} from './resolvers'\n\nexport {\n  vueResolver,\n  reactResolver,\n  solidResolver,\n} from './resolvers'\nexport { syncIndexResolver } from './options'\nexport { PageContext }\nexport default pagesPlugin\n"],"mappings":"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","names":["join","resolve","resolve","isNewEscapeSequence","isCloseEscapeSequence","isStartOfLayoutSegment","parent","route","prepareRoutes","parent","prepareRoutes","parent","resolve","resolve","join"]}