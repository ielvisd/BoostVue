import { h as handler, l as resolveBreakpoints, q as getBracket, C as CONTROL_MINI_NO_NEGATIVE, s as getComponent } from './preset-mini.690517b1.mjs';
import { warnOnce, escapeRegExp, escapeSelector } from '@unocss/core';
import { v as variantGetParameter, a as variantGetBracket, b as variantParentMatcher, c as variantMatcher } from './preset-mini.74d943b2.mjs';

const variantAria = {
  name: "aria",
  match(matcher, { theme }) {
    const variant = variantGetParameter("aria-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      const aria = handler.bracket(match) ?? theme.aria?.[match] ?? "";
      if (aria) {
        return {
          matcher: rest,
          selector: (s) => `${s}[aria-${aria}]`
        };
      }
    }
  }
};

const regexCache = {};
const calcMaxWidthBySize = (size) => {
  const value = size.match(/^-?[0-9]+\.?[0-9]*/)?.[0] || "";
  const unit = size.slice(value.length);
  const maxWidth = parseFloat(value) - 0.1;
  return Number.isNaN(maxWidth) ? size : `${maxWidth}${unit}`;
};
const variantBreakpoints = {
  name: "breakpoints",
  match(matcher, context) {
    const variantEntries = Object.entries(resolveBreakpoints(context) ?? {}).map(([point, size], idx) => [point, size, idx]);
    for (const [point, size, idx] of variantEntries) {
      if (!regexCache[point])
        regexCache[point] = new RegExp(`^((?:[al]t-)?${point}[:-])`);
      const match = matcher.match(regexCache[point]);
      if (!match)
        continue;
      const [, pre] = match;
      const m = matcher.slice(pre.length);
      if (m === "container")
        continue;
      const isLtPrefix = pre.startsWith("lt-");
      const isAtPrefix = pre.startsWith("at-");
      let order = 1e3;
      if (isLtPrefix) {
        order -= idx + 1;
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (max-width: ${calcMaxWidthBySize(size)})`,
            parentOrder: order
          })
        };
      }
      order += idx + 1;
      if (isAtPrefix && idx < variantEntries.length - 1) {
        return {
          matcher: m,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size}) and (max-width: ${calcMaxWidthBySize(variantEntries[idx + 1][1])})`,
            parentOrder: order
          })
        };
      }
      return {
        matcher: m,
        handle: (input, next) => next({
          ...input,
          parent: `${input.parent ? `${input.parent} $$ ` : ""}@media (min-width: ${size})`,
          parentOrder: order
        })
      };
    }
  },
  multiPass: true,
  autocomplete: "(at-|lt-|)$breakpoints:"
};

const scopeMatcher = (name, combinator) => ({
  name: `combinator:${name}`,
  match(matcher) {
    if (!matcher.startsWith(name))
      return;
    let body = variantGetBracket(`${name}-`, matcher, [":", "-"]);
    if (!body) {
      for (const separator of [":", "-"]) {
        if (matcher.startsWith(`${name}${separator}`)) {
          body = ["", matcher.slice(name.length + separator.length)];
          break;
        }
      }
      if (!body)
        return;
    }
    let bracketValue = handler.bracket(body[0]) ?? "";
    if (bracketValue === "")
      bracketValue = "*";
    return {
      matcher: body[1],
      selector: (s) => `${s}${combinator}${bracketValue}`
    };
  },
  multiPass: true
});
const variantCombinators = [
  scopeMatcher("all", " "),
  scopeMatcher("children", ">"),
  scopeMatcher("next", "+"),
  scopeMatcher("sibling", "+"),
  scopeMatcher("siblings", "~")
];

const variantContainerQuery = {
  name: "@",
  match(matcher, { theme }) {
    if (matcher.startsWith("@container"))
      return;
    const variant = variantGetParameter("@", matcher, [":", "-"]);
    if (variant) {
      const [match, rest, label] = variant;
      const unbracket = handler.bracket(match);
      let container;
      if (unbracket) {
        const minWidth = handler.numberWithUnit(unbracket);
        if (minWidth)
          container = `(min-width: ${minWidth})`;
      } else {
        container = theme.containers?.[match] ?? "";
      }
      if (container) {
        warnOnce("The container query variant is experimental and may not follow semver.");
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@container${label ? ` ${label} ` : " "}${container}`
          })
        };
      }
    }
  },
  multiPass: true
};

const variantDataAttribute = {
  name: "data",
  match(matcher, { theme }) {
    const variant = variantGetParameter("data-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      const dataAttribute = handler.bracket(match) ?? theme.data?.[match] ?? "";
      if (dataAttribute) {
        return {
          matcher: rest,
          selector: (s) => `${s}[data-${dataAttribute}]`
        };
      }
    }
  }
};

const variantPrint = variantParentMatcher("print", "@media print");
const variantCustomMedia = {
  name: "media",
  match(matcher, { theme }) {
    const variant = variantGetParameter("media-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      let media = handler.bracket(match) ?? "";
      if (media === "")
        media = theme.media?.[match] ?? "";
      if (media) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@media ${media}`
          })
        };
      }
    }
  },
  multiPass: true
};

const variantSupports = {
  name: "supports",
  match(matcher, { theme }) {
    const variant = variantGetParameter("supports-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      let supports = handler.bracket(match) ?? "";
      if (supports === "")
        supports = theme.supports?.[match] ?? "";
      if (supports) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@supports ${supports}`
          })
        };
      }
    }
  },
  multiPass: true
};

const variantColorsMediaOrClass = (options = {}) => {
  if (options?.dark === "class" || typeof options.dark === "object") {
    const { dark = ".dark", light = ".light" } = typeof options.dark === "string" ? {} : options.dark;
    return [
      variantMatcher("dark", (input) => ({ prefix: `${dark} $$ ${input.prefix}` })),
      variantMatcher("light", (input) => ({ prefix: `${light} $$ ${input.prefix}` }))
    ];
  }
  return [
    variantParentMatcher("dark", "@media (prefers-color-scheme: dark)"),
    variantParentMatcher("light", "@media (prefers-color-scheme: light)")
  ];
};

const variantLanguageDirections = [
  variantMatcher("rtl", (input) => ({ prefix: `[dir="rtl"] $$ ${input.prefix}` })),
  variantMatcher("ltr", (input) => ({ prefix: `[dir="ltr"] $$ ${input.prefix}` }))
];

const variantSelector = {
  name: "selector",
  match(matcher) {
    const variant = variantGetBracket("selector-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      const selector = handler.bracket(match);
      if (selector) {
        return {
          matcher: rest,
          selector: () => selector
        };
      }
    }
  }
};
const variantCssLayer = {
  name: "layer",
  match(matcher) {
    const variant = variantGetParameter("layer-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      const layer = handler.bracket(match) ?? match;
      if (layer) {
        return {
          matcher: rest,
          handle: (input, next) => next({
            ...input,
            parent: `${input.parent ? `${input.parent} $$ ` : ""}@layer ${layer}`
          })
        };
      }
    }
  }
};
const variantInternalLayer = {
  name: "uno-layer",
  match(matcher) {
    const variant = variantGetParameter("uno-layer-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      const layer = handler.bracket(match) ?? match;
      if (layer) {
        return {
          matcher: rest,
          layer
        };
      }
    }
  }
};
const variantScope = {
  name: "scope",
  match(matcher) {
    const variant = variantGetBracket("scope-", matcher, [":", "-"]);
    if (variant) {
      const [match, rest] = variant;
      const scope = handler.bracket(match);
      if (scope) {
        return {
          matcher: rest,
          selector: (s) => `${scope} $$ ${s}`
        };
      }
    }
  }
};
const variantVariables = {
  name: "variables",
  match(matcher) {
    if (!matcher.startsWith("["))
      return;
    const [match, rest] = getBracket(matcher, "[", "]") ?? [];
    if (!(match && rest))
      return;
    let newMatcher;
    for (const separator of [":", "-"]) {
      if (rest.startsWith(separator)) {
        newMatcher = rest.slice(separator.length);
        break;
      }
    }
    if (newMatcher == null)
      return;
    const variant = handler.bracket(match) ?? "";
    const useParent = variant.startsWith("@");
    if (!(useParent || variant.includes("&")))
      return;
    return {
      matcher: newMatcher,
      handle(input, next) {
        const updates = useParent ? {
          parent: `${input.parent ? `${input.parent} $$ ` : ""}${variant}`
        } : {
          selector: variant.replace(/&/g, input.selector)
        };
        return next({
          ...input,
          ...updates
        });
      }
    };
  },
  multiPass: true
};

const numberRE = /[0-9.]+(?:[a-z]+|%)?/;
const ignoreProps = [
  /opacity|color|flex/
];
const negateFunctions = (value) => {
  const match = value.match(/^(calc|clamp|max|min)\s*(\(.*)/);
  if (match) {
    const [fnBody, rest] = getComponent(match[2], "(", ")", " ") ?? [];
    if (fnBody)
      return `calc(${match[1]}${fnBody} * -1)${rest ? ` ${rest}` : ""}`;
  }
};
const variantNegative = {
  name: "negative",
  match(matcher) {
    if (!matcher.startsWith("-"))
      return;
    return {
      matcher: matcher.slice(1),
      body: (body) => {
        if (body.find((v) => v[0] === CONTROL_MINI_NO_NEGATIVE))
          return;
        let changed = false;
        body.forEach((v) => {
          const value = v[1]?.toString();
          if (!value || value === "0")
            return;
          if (ignoreProps.some((i) => v[0].match(i)))
            return;
          const negated = negateFunctions(value);
          if (negated) {
            v[1] = negated;
            changed = true;
          } else if (numberRE.test(value)) {
            v[1] = value.replace(numberRE, (i) => `-${i}`);
            changed = true;
          }
        });
        if (changed)
          return body;
        return [];
      }
    };
  }
};

const variantImportant = {
  name: "important",
  match(matcher) {
    let base;
    const match = matcher.match(/^(important[:-]|!)/);
    if (match)
      base = matcher.slice(match[0].length);
    else if (matcher.endsWith("!"))
      base = matcher.slice(0, -1);
    if (base) {
      return {
        matcher: base,
        body: (body) => {
          body.forEach((v) => {
            if (v[1])
              v[1] += " !important";
          });
          return body;
        }
      };
    }
  }
};

const PseudoClasses = Object.fromEntries([
  ["first-letter", "::first-letter"],
  ["first-line", "::first-line"],
  "any-link",
  "link",
  "visited",
  "target",
  ["open", "[open]"],
  "hover",
  "active",
  "focus-visible",
  "focus-within",
  "focus",
  "autofill",
  "enabled",
  "disabled",
  "read-only",
  "read-write",
  "placeholder-shown",
  "default",
  "checked",
  "indeterminate",
  "valid",
  "invalid",
  "in-range",
  "out-of-range",
  "required",
  "optional",
  "root",
  "empty",
  ["even-of-type", ":nth-of-type(even)"],
  ["even", ":nth-child(even)"],
  ["odd-of-type", ":nth-of-type(odd)"],
  ["odd", ":nth-child(odd)"],
  "first-of-type",
  ["first", ":first-child"],
  "last-of-type",
  ["last", ":last-child"],
  "only-child",
  "only-of-type",
  ["placeholder", "::placeholder"],
  ["before", "::before"],
  ["after", "::after"],
  ["selection", "::selection"],
  ["marker", "::marker"],
  ["file", "::file-selector-button"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
const PseudoClassesColon = Object.fromEntries([
  ["backdrop", "::backdrop"]
].map((key) => Array.isArray(key) ? key : [key, `:${key}`]));
const PseudoClassFunctions = [
  "not",
  "is",
  "where",
  "has"
];
const PseudoClassesStr = Object.entries(PseudoClasses).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).join("|");
const PseudoClassesColonStr = Object.entries(PseudoClassesColon).filter(([, pseudo]) => !pseudo.startsWith("::")).map(([key]) => key).join("|");
const PseudoClassFunctionsStr = PseudoClassFunctions.join("|");
const sortValue = (pseudo) => {
  if (pseudo === "active")
    return 1;
};
const taggedPseudoClassMatcher = (tag, parent, combinator) => {
  const rawRE = new RegExp(`^(${escapeRegExp(parent)}:)(\\S+)${escapeRegExp(combinator)}\\1`);
  const pseudoRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesStr}))(?:(/\\w+))?[:-]`);
  const pseudoColonRE = new RegExp(`^${tag}-(?:(?:(${PseudoClassFunctionsStr})-)?(${PseudoClassesColonStr}))(?:(/\\w+))?[:]`);
  const matchBracket = (input) => {
    const body = variantGetBracket(`${tag}-`, input, []);
    if (!body)
      return;
    const [match, rest] = body;
    const bracketValue = handler.bracket(match);
    if (bracketValue == null)
      return;
    const label = rest.split(/[:-]/, 1)?.[0] ?? "";
    const prefix = `${parent}${escapeSelector(label)}`;
    return [
      label,
      input.slice(input.length - (rest.length - label.length - 1)),
      bracketValue.includes("&") ? bracketValue.replace(/&/g, prefix) : `${prefix}${bracketValue}`
    ];
  };
  const matchPseudo = (input) => {
    const match = input.match(pseudoRE) || input.match(pseudoColonRE);
    if (!match)
      return;
    const [original, fn, pseudoKey] = match;
    const label = match[3] ?? "";
    let pseudo = PseudoClasses[pseudoKey] || PseudoClassesColon[pseudoKey] || `:${pseudoKey}`;
    if (fn)
      pseudo = `:${fn}(${pseudo})`;
    return [
      label,
      input.slice(original.length),
      `${parent}${escapeSelector(label)}${pseudo}`,
      sortValue(pseudoKey)
    ];
  };
  return {
    name: `pseudo:${tag}`,
    match(input) {
      if (!input.startsWith(tag))
        return;
      const result = matchBracket(input) || matchPseudo(input);
      if (!result)
        return;
      const [label, matcher, prefix, sort] = result;
      if (label !== "")
        warnOnce("The labeled variant is experimental and may not follow semver.");
      return {
        matcher,
        handle: (input2, next) => next({
          ...input2,
          prefix: `${prefix}${combinator}${input2.prefix}`.replace(rawRE, "$1$2:")
        }),
        sort
      };
    },
    multiPass: true
  };
};
const PseudoClassesAndElementsStr = Object.entries(PseudoClasses).map(([key]) => key).join("|");
const PseudoClassesAndElementsColonStr = Object.entries(PseudoClassesColon).map(([key]) => key).join("|");
const PseudoClassesAndElementsRE = new RegExp(`^(${PseudoClassesAndElementsStr})[:-]`);
const PseudoClassesAndElementsColonRE = new RegExp(`^(${PseudoClassesAndElementsColonStr})[:]`);
const variantPseudoClassesAndElements = {
  name: "pseudo",
  match(input) {
    const match = input.match(PseudoClassesAndElementsRE) || input.match(PseudoClassesAndElementsColonRE);
    if (match) {
      const pseudo = PseudoClasses[match[1]] || PseudoClassesColon[match[1]] || `:${match[1]}`;
      return {
        matcher: input.slice(match[0].length),
        handle: (input2, next) => {
          const selectors = pseudo.startsWith("::") ? {
            pseudo: `${input2.pseudo}${pseudo}`
          } : {
            selector: `${input2.selector}${pseudo}`
          };
          return next({
            ...input2,
            ...selectors,
            sort: sortValue(match[1])
          });
        }
      };
    }
  },
  multiPass: true,
  autocomplete: `(${PseudoClassesAndElementsStr}):`
};
const PseudoClassFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesStr})[:-]`);
const PseudoClassColonFunctionsRE = new RegExp(`^(${PseudoClassFunctionsStr})-(${PseudoClassesColonStr})[:]`);
const variantPseudoClassFunctions = {
  match(input) {
    const match = input.match(PseudoClassFunctionsRE) || input.match(PseudoClassColonFunctionsRE);
    if (match) {
      const fn = match[1];
      const pseudo = PseudoClasses[match[2]] || PseudoClassesColon[match[2]] || `:${match[2]}`;
      return {
        matcher: input.slice(match[0].length),
        selector: (s) => `${s}:${fn}(${pseudo})`
      };
    }
  },
  multiPass: true,
  autocomplete: `(${PseudoClassFunctionsStr})-(${PseudoClassesStr}|${PseudoClassesColonStr}):`
};
const variantTaggedPseudoClasses = (options = {}) => {
  const attributify = !!options?.attributifyPseudo;
  return [
    taggedPseudoClassMatcher("group", attributify ? '[group=""]' : ".group", " "),
    taggedPseudoClassMatcher("peer", attributify ? '[peer=""]' : ".peer", "~"),
    taggedPseudoClassMatcher("parent", attributify ? '[parent=""]' : ".parent", ">"),
    taggedPseudoClassMatcher("previous", attributify ? '[previous=""]' : ".previous", "+")
  ];
};
const PartClassesRE = /(part-\[(.+)]:)(.+)/;
const partClasses = {
  match(input) {
    const match = input.match(PartClassesRE);
    if (match) {
      const part = `part(${match[2]})`;
      return {
        matcher: input.slice(match[1].length),
        selector: (s) => `${s}::${part}`
      };
    }
  },
  multiPass: true
};

const variants = (options) => [
  variantAria,
  variantDataAttribute,
  variantCssLayer,
  variantSelector,
  variantInternalLayer,
  variantNegative,
  variantImportant,
  variantSupports,
  variantPrint,
  variantCustomMedia,
  variantBreakpoints,
  ...variantCombinators,
  variantPseudoClassesAndElements,
  variantPseudoClassFunctions,
  ...variantTaggedPseudoClasses(options),
  partClasses,
  ...variantColorsMediaOrClass(options),
  ...variantLanguageDirections,
  variantScope,
  variantContainerQuery,
  variantVariables
];

export { variantAria as a, variantBreakpoints as b, calcMaxWidthBySize as c, variantCombinators as d, variantContainerQuery as e, variantDataAttribute as f, variantPrint as g, variantCustomMedia as h, variantSupports as i, variantColorsMediaOrClass as j, variantLanguageDirections as k, variantSelector as l, variantCssLayer as m, variantInternalLayer as n, variantScope as o, variantVariables as p, variantPseudoClassesAndElements as q, variantPseudoClassFunctions as r, variantTaggedPseudoClasses as s, partClasses as t, variantImportant as u, variants as v, variantNegative as w };
