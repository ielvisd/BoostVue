import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import require$$0 from 'tty';
import { run, parseNi, parseNu } from '@antfu/ni';
import prompts from 'prompts';
import require$$0$1 from 'readline';
import require$$3 from 'events';
import { _ as _debug, t as toArray, e as DiffMap, D as DependenciesTypeShortMap, u as updateTargetVersion, g as getVersionOfRange, f as getPrefixedVersion, C as CheckPackages, w as writePackage, c as loadPackages, h as getPackageData } from './shared/taze.058dfbad.mjs';
import { createConfigLoader } from 'unconfig';
import semver from 'semver';
import 'path';
import 'fs';
import 'os';
import 'util';
import 'stream';
import 'detect-indent';
import 'pacote';
import '@npmcli/config';

var picocolors = {exports: {}};

let tty = require$$0;

let isColorSupported =
	!("NO_COLOR" in process.env || process.argv.includes("--no-color")) &&
	("FORCE_COLOR" in process.env ||
		process.argv.includes("--color") ||
		process.platform === "win32" ||
		(tty.isatty(1) && process.env.TERM !== "dumb") ||
		"CI" in process.env);

let formatter$1 =
	(open, close, replace = open) =>
	input => {
		let string = "" + input;
		let index = string.indexOf(close, open.length);
		return ~index
			? open + replaceClose(string, close, replace, index) + close
			: open + string + close
	};

let replaceClose = (string, close, replace, index) => {
	let start = string.substring(0, index) + replace;
	let end = string.substring(index + close.length);
	let nextIndex = end.indexOf(close);
	return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end
};

let createColors = (enabled = isColorSupported) => ({
	isColorSupported: enabled,
	reset: enabled ? s => `\x1b[0m${s}\x1b[0m` : String,
	bold: enabled ? formatter$1("\x1b[1m", "\x1b[22m", "\x1b[22m\x1b[1m") : String,
	dim: enabled ? formatter$1("\x1b[2m", "\x1b[22m", "\x1b[22m\x1b[2m") : String,
	italic: enabled ? formatter$1("\x1b[3m", "\x1b[23m") : String,
	underline: enabled ? formatter$1("\x1b[4m", "\x1b[24m") : String,
	inverse: enabled ? formatter$1("\x1b[7m", "\x1b[27m") : String,
	hidden: enabled ? formatter$1("\x1b[8m", "\x1b[28m") : String,
	strikethrough: enabled ? formatter$1("\x1b[9m", "\x1b[29m") : String,
	black: enabled ? formatter$1("\x1b[30m", "\x1b[39m") : String,
	red: enabled ? formatter$1("\x1b[31m", "\x1b[39m") : String,
	green: enabled ? formatter$1("\x1b[32m", "\x1b[39m") : String,
	yellow: enabled ? formatter$1("\x1b[33m", "\x1b[39m") : String,
	blue: enabled ? formatter$1("\x1b[34m", "\x1b[39m") : String,
	magenta: enabled ? formatter$1("\x1b[35m", "\x1b[39m") : String,
	cyan: enabled ? formatter$1("\x1b[36m", "\x1b[39m") : String,
	white: enabled ? formatter$1("\x1b[37m", "\x1b[39m") : String,
	gray: enabled ? formatter$1("\x1b[90m", "\x1b[39m") : String,
	bgBlack: enabled ? formatter$1("\x1b[40m", "\x1b[49m") : String,
	bgRed: enabled ? formatter$1("\x1b[41m", "\x1b[49m") : String,
	bgGreen: enabled ? formatter$1("\x1b[42m", "\x1b[49m") : String,
	bgYellow: enabled ? formatter$1("\x1b[43m", "\x1b[49m") : String,
	bgBlue: enabled ? formatter$1("\x1b[44m", "\x1b[49m") : String,
	bgMagenta: enabled ? formatter$1("\x1b[45m", "\x1b[49m") : String,
	bgCyan: enabled ? formatter$1("\x1b[46m", "\x1b[49m") : String,
	bgWhite: enabled ? formatter$1("\x1b[47m", "\x1b[49m") : String,
});

picocolors.exports = createColors();
picocolors.exports.createColors = createColors;

const version = "0.8.4";

// ETA calculation
class ETA{

    constructor(length, initTime, initValue){
        // size of eta buffer
        this.etaBufferLength = length || 100;

        // eta buffer with initial values
        this.valueBuffer = [initValue];
        this.timeBuffer = [initTime];

        // eta time value
        this.eta = '0';
    }

    // add new values to calculation buffer
    update(time, value, total){
        this.valueBuffer.push(value);
        this.timeBuffer.push(time);

        // trigger recalculation
        this.calculate(total-value);
    }

    // fetch estimated time
    getTime(){
        return this.eta;
    }

    // eta calculation - request number of remaining events
    calculate(remaining){
        // get number of samples in eta buffer
        const currentBufferSize = this.valueBuffer.length;
        const buffer = Math.min(this.etaBufferLength, currentBufferSize);

        const v_diff = this.valueBuffer[currentBufferSize - 1] - this.valueBuffer[currentBufferSize - buffer];
        const t_diff = this.timeBuffer[currentBufferSize - 1] - this.timeBuffer[currentBufferSize - buffer];

        // get progress per ms
        const vt_rate = v_diff/t_diff;

        // strip past elements
        this.valueBuffer = this.valueBuffer.slice(-this.etaBufferLength);
        this.timeBuffer  = this.timeBuffer.slice(-this.etaBufferLength);

        // eq: vt_rate *x = total
        const eta = Math.ceil(remaining/vt_rate/1000);

        // check values
        if (isNaN(eta)){
            this.eta = 'NULL';

        // +/- Infinity --- NaN already handled
        }else if (!isFinite(eta)){
            this.eta = 'INF';

        // > 10M s ? - set upper display limit ~115days (1e7/60/60/24)
        }else if (eta > 1e7){
            this.eta = 'INF';

        // negative ?
        }else if (eta < 0){
            this.eta = 0;

        }else {
            // assign
            this.eta = eta;
        }
    }
}

var eta = ETA;

const _readline = require$$0$1;

// low-level terminal interactions
class Terminal{

    constructor(outputStream){
        this.stream = outputStream;

        // default: line wrapping enabled
        this.linewrap = true;

        // current, relative y position
        this.dy = 0;
    }

    // save cursor position + settings
    cursorSave(){
        if (!this.stream.isTTY){
            return;
        }

        // save position
        this.stream.write('\x1B7');
    }

    // restore last cursor position + settings
    cursorRestore(){
        if (!this.stream.isTTY){
            return;
        }

        // restore cursor
        this.stream.write('\x1B8');
    }

    // show/hide cursor
    cursor(enabled){
        if (!this.stream.isTTY){
            return;
        }

        if (enabled){
            this.stream.write('\x1B[?25h');
        }else {
            this.stream.write('\x1B[?25l');
        }
    }

    // change cursor positionn
    cursorTo(x=null, y=null){
        if (!this.stream.isTTY){
            return;
        }

        // move cursor absolute
        _readline.cursorTo(this.stream, x, y);
    }

    // change relative cursor position
    cursorRelative(dx=null, dy=null){
        if (!this.stream.isTTY){
            return;
        }

        // store current position
        this.dy = this.dy + dy;
        
        // move cursor relative
        _readline.moveCursor(this.stream, dx, dy);
    }

    // relative reset
    cursorRelativeReset(){
        if (!this.stream.isTTY){
            return;
        }

        // move cursor to initial line
        _readline.moveCursor(this.stream, 0, -this.dy);

        // first char
        _readline.cursorTo(this.stream, 0, null);

        // reset counter
        this.dy = 0;
    }

    // clear to the right from cursor
    clearRight(){
        if (!this.stream.isTTY){
            return;
        }

        _readline.clearLine(this.stream, 1);
    }

    // clear the full line
    clearLine(){
        if (!this.stream.isTTY){
            return;
        }

        _readline.clearLine(this.stream, 0);
    }

    // clear everyting beyond the current line
    clearBottom(){
        if (!this.stream.isTTY){
            return;
        }

        _readline.clearScreenDown(this.stream);
    }

    // add new line; increment counter
    newline(){
        this.stream.write('\n');
        this.dy++;
    }

    // write content to output stream
    // @TODO use string-width to strip length
    write(s, rawWrite=false){
        // line wrapping enabled ? trim output
        if (this.linewrap === true && rawWrite === false){
            this.stream.write(s.substr(0, this.getWidth()));
        }else {
            this.stream.write(s);
        }
    }

    // control line wrapping
    lineWrapping(enabled){
        if (!this.stream.isTTY){
            return;
        }

        // store state
        this.linewrap = enabled;
        if (enabled){
            this.stream.write('\x1B[?7h');
        }else {
            this.stream.write('\x1B[?7l');
        }
    }

    // tty environment ?
    isTTY(){
        return (this.stream.isTTY === true);
    }

    // get terminal width
    getWidth(){
        // set max width to 80 in tty-mode and 200 in notty-mode
        return this.stream.columns || (this.stream.isTTY ? 80 : 200);
    }
}

var terminal = Terminal;

var stringWidth$1 = {exports: {}};

var ansiRegex$2 = ({onlyFirst = false} = {}) => {
	const pattern = [
		'[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)',
		'(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'
	].join('|');

	return new RegExp(pattern, onlyFirst ? undefined : 'g');
};

const ansiRegex$1 = ansiRegex$2;

var stripAnsi$2 = string => typeof string === 'string' ? string.replace(ansiRegex$1(), '') : string;

var isFullwidthCodePoint$2 = {exports: {}};

/* eslint-disable yoda */

const isFullwidthCodePoint$1 = codePoint => {
	if (Number.isNaN(codePoint)) {
		return false;
	}

	// Code points are derived from:
	// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt
	if (
		codePoint >= 0x1100 && (
			codePoint <= 0x115F || // Hangul Jamo
			codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
			codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
			// CJK Radicals Supplement .. Enclosed CJK Letters and Months
			(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||
			// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
			(0x3250 <= codePoint && codePoint <= 0x4DBF) ||
			// CJK Unified Ideographs .. Yi Radicals
			(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||
			// Hangul Jamo Extended-A
			(0xA960 <= codePoint && codePoint <= 0xA97C) ||
			// Hangul Syllables
			(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||
			// CJK Compatibility Ideographs
			(0xF900 <= codePoint && codePoint <= 0xFAFF) ||
			// Vertical Forms
			(0xFE10 <= codePoint && codePoint <= 0xFE19) ||
			// CJK Compatibility Forms .. Small Form Variants
			(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||
			// Halfwidth and Fullwidth Forms
			(0xFF01 <= codePoint && codePoint <= 0xFF60) ||
			(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||
			// Kana Supplement
			(0x1B000 <= codePoint && codePoint <= 0x1B001) ||
			// Enclosed Ideographic Supplement
			(0x1F200 <= codePoint && codePoint <= 0x1F251) ||
			// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
			(0x20000 <= codePoint && codePoint <= 0x3FFFD)
		)
	) {
		return true;
	}

	return false;
};

isFullwidthCodePoint$2.exports = isFullwidthCodePoint$1;
isFullwidthCodePoint$2.exports.default = isFullwidthCodePoint$1;

var emojiRegex$1 = function () {
  // https://mths.be/emoji
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};

const stripAnsi$1 = stripAnsi$2;
const isFullwidthCodePoint = isFullwidthCodePoint$2.exports;
const emojiRegex = emojiRegex$1;

const stringWidth = string => {
	if (typeof string !== 'string' || string.length === 0) {
		return 0;
	}

	string = stripAnsi$1(string);

	if (string.length === 0) {
		return 0;
	}

	string = string.replace(emojiRegex(), '  ');

	let width = 0;

	for (let i = 0; i < string.length; i++) {
		const code = string.codePointAt(i);

		// Ignore control characters
		if (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {
			continue;
		}

		// Ignore combining characters
		if (code >= 0x300 && code <= 0x36F) {
			continue;
		}

		// Surrogates
		if (code > 0xFFFF) {
			i++;
		}

		width += isFullwidthCodePoint(code) ? 2 : 1;
	}

	return width;
};

stringWidth$1.exports = stringWidth;
// TODO: remove this in the next major version
stringWidth$1.exports.default = stringWidth;

// default value format (apply autopadding)

// format valueset
var formatValue = function formatValue(v, options, type){
    // no autopadding ? passthrough
    if (options.autopadding !== true){
        return v;
    }

    // padding
    function autopadding(value, length){
        return (options.autopaddingChar + value).slice(-length);
    }

    switch (type){
        case 'percentage':
            return autopadding(v, 3);

        default:
            return v;
    }
};

// format bar
var formatBar = function formatBar(progress, options){
    // calculate barsize
    const completeSize = Math.round(progress*options.barsize);
    const incompleteSize = options.barsize-completeSize;

   // generate bar string by stripping the pre-rendered strings
   return   options.barCompleteString.substr(0, completeSize) +
            options.barGlue +
            options.barIncompleteString.substr(0, incompleteSize);
};

// default time format

// format a number of seconds into hours and minutes as appropriate
var formatTime = function formatTime(t, options, roundToMultipleOf){
    function round(input) {
        if (roundToMultipleOf) {
            return roundToMultipleOf * Math.round(input / roundToMultipleOf);
        } else {
            return input
        }
    }

    // leading zero padding
    function autopadding(v){
        return (options.autopaddingChar + v).slice(-2);
    }

    // > 1h ?
    if (t > 3600) {
        return autopadding(Math.floor(t / 3600)) + 'h' + autopadding(round((t % 3600) / 60)) + 'm';

    // > 60s ?
    } else if (t > 60) {
        return autopadding(Math.floor(t / 60)) + 'm' + autopadding(round((t % 60))) + 's';

    // > 10s ?
    } else if (t > 10) {
        return autopadding(round(t)) + 's';

    // default: don't apply round to multiple
    }else {
        return autopadding(t) + 's';
    }
};

const _stringWidth = stringWidth$1.exports;
const _defaultFormatValue$1 = formatValue;
const _defaultFormatBar$1 = formatBar;
const _defaultFormatTime$1 = formatTime;

// generic formatter
var formatter = function defaultFormatter(options, params, payload){

    // copy format string
    let s = options.format;

    // custom time format set ?
    const formatTime = options.formatTime || _defaultFormatTime$1;
    
    // custom value format set ?
    const formatValue = options.formatValue || _defaultFormatValue$1;

    // custom bar format set ?
    const formatBar = options.formatBar || _defaultFormatBar$1;

    // calculate progress in percent
    const percentage =  Math.floor(params.progress*100) + '';

    // bar stopped and stopTime set ?
    const stopTime = params.stopTime || Date.now();

    // calculate elapsed time
    const elapsedTime = Math.round((stopTime - params.startTime)/1000);

    // merges data from payload and calculated
    const context = Object.assign({}, payload, {
        bar:                    formatBar(params.progress, options),

        percentage:             formatValue(percentage, options, 'percentage'),
        total:                  formatValue(params.total, options, 'total'),
        value:                  formatValue(params.value, options, 'value'),

        eta:                    formatValue(params.eta, options, 'eta'),
        eta_formatted:          formatTime(params.eta, options, 5),
        
        duration:               formatValue(elapsedTime, options, 'duration'),
        duration_formatted:     formatTime(elapsedTime, options, 1)
    });

    // assign placeholder tokens
    s = s.replace(/\{(\w+)\}/g, function(match, key){
        // key exists within payload/context
        if (typeof context[key] !== 'undefined') {
            return context[key];
        }

        // no changes to unknown values
        return match;
    });

    // calculate available whitespace (2 characters margin of error)
    const fullMargin = Math.max(0, params.maxWidth - _stringWidth(s) -2);
    const halfMargin = Math.floor(fullMargin / 2);

    // distribute available whitespace according to position
    switch (options.align) {

        // fill start-of-line with whitespaces
        case 'right':
            s = (fullMargin > 0) ? ' '.repeat(fullMargin) + s : s;
            break;

        // distribute whitespaces to left+right
        case 'center':
            s = (halfMargin > 0) ? ' '.repeat(halfMargin) + s : s;
            break;
    }

    return s;
};

const _ETA = eta;
const _Terminal$1 = terminal;
const _formatter = formatter;
const _EventEmitter$1 = require$$3;

// Progress-Bar constructor
var genericBar = class GenericBar extends _EventEmitter$1{

    constructor(options){
        super();

        // store options
        this.options = options;

        // store terminal instance
        this.terminal = (this.options.terminal) ? this.options.terminal : new _Terminal$1(this.options.stream);

        // the current bar value
        this.value = 0;

        // bar start value (used for progress calculation)
        this.startValue = 0;

        // the end value of the bar
        this.total = 100;

        // last drawn string - only render on change!
        this.lastDrawnString = null;

        // start time (used for eta calculation)
        this.startTime = null;

        // stop time (used for duration calculation)
        this.stopTime = null;

        // last update time
        this.lastRedraw = Date.now();

        // default eta calculator (will be re-create on start)
        this.eta = new _ETA(this.options.etaBufferLength, 0, 0);

        // payload data
        this.payload = {};

        // progress bar active ?
        this.isActive = false;

        // use default formatter or custom one ?
        this.formatter = (typeof this.options.format === 'function') ? this.options.format : _formatter;
    }

    // internal render function
    render(forceRendering=false){

        // formatter params
        const params = {
            progress: this.getProgress(),
            eta: this.eta.getTime(),
            startTime: this.startTime,
            stopTime: this.stopTime,
            total: this.total,
            value: this.value,
            maxWidth: this.terminal.getWidth()
        };

        // automatic eta update ? (long running processes)
        if (this.options.etaAsynchronousUpdate){
            this.updateETA();
        }

        // format string
        const s = this.formatter(this.options, params, this.payload);

        const forceRedraw = forceRendering || this.options.forceRedraw
            // force redraw in notty-mode!
            || (this.options.noTTYOutput && !this.terminal.isTTY());

        // string changed ? only trigger redraw on change!
        if (forceRedraw || this.lastDrawnString != s){
            // trigger event
            this.emit('redraw-pre');

            // set cursor to start of line
            this.terminal.cursorTo(0, null);

            // write output
            this.terminal.write(s);

            // clear to the right from cursor
            this.terminal.clearRight();

            // store string
            this.lastDrawnString = s;

            // set last redraw time
            this.lastRedraw = Date.now();

            // trigger event
            this.emit('redraw-post');
        }
    }

    // start the progress bar
    start(total, startValue, payload){
        // set initial values
        this.value = startValue || 0;
        this.total = (typeof total !== 'undefined' && total >= 0) ? total : 100;

        // set start value for progress calculation
        this.startValue = (startValue || 0);

        // store payload (optional)
        this.payload = payload || {};

        // store start time for duration+eta calculation
        this.startTime = Date.now();

        // reset stop time for 're-start' scenario (used for duration calculation)
        this.stopTime = null;

        // reset string line buffer (redraw detection)
        this.lastDrawnString = '';

        // initialize eta buffer
        this.eta = new _ETA(this.options.etaBufferLength, this.startTime, this.value);

        // set flag
        this.isActive = true;

        // start event
        this.emit('start', total, startValue);
    }

    // stop the bar
    stop(){
        // set flag
        this.isActive = false;
        
        // store stop timestamp to get total duration
        this.stopTime = Date.now();

        // stop event
        this.emit('stop', this.total, this.value);
    }

    // update the bar value
    // update(value, payload)
    // update(payload)
    update(arg0, arg1 = {}){
        // value set ?
        // update(value, [payload]);
        if (typeof arg0 === 'number') {
            // update value
            this.value = arg0;

            // add new value; recalculate eta
            this.eta.update(Date.now(), arg0, this.total);
        }

        // extract payload
        // update(value, payload)
        // update(payload)
        const payloadData = ((typeof arg0 === 'object') ? arg0 : arg1) || {};

        // update event (before stop() is called)
        this.emit('update', this.total, this.value);

        // merge payload
        for (const key in payloadData){
            this.payload[key] = payloadData[key];
        }

        // limit reached ? autostop set ?
        if (this.value >= this.getTotal() && this.options.stopOnComplete) {
            this.stop();
        }
    }

    // calculate the actual progress value
    getProgress(){
        // calculate the normalized current progress
        let progress = (this.value/this.total);

        // use relative progress calculation ? range between startValue and total is then used as 100%
        // startValue (offset) is ignored for calculations
        if (this.options.progressCalculationRelative){
            progress = (this.value-this.startValue)/(this.total-this.startValue);
        }

        // handle NaN Errors caused by total=0. Set to complete in this case
        if (isNaN(progress)){
            progress = (this.options && this.options.emptyOnZero) ? 0.0 : 1.0;
        }

        // limiter
        progress = Math.min(Math.max(progress, 0.0), 1.0);

        return progress;
    }

    // update the bar value
    // increment(delta, payload)
    // increment(payload)
    increment(arg0 = 1, arg1 = {}){
        // increment([payload]) => step=1
        // handle the use case when `step` is omitted but payload is passed
        if (typeof arg0 === 'object') {
            this.update(this.value + 1, arg0);
        
        // increment([step=1], [payload={}])
        }else {
            this.update(this.value + arg0, arg1);
        }
    }

    // get the total (limit) value
    getTotal(){
        return this.total;
    }

    // set the total (limit) value
    setTotal(total){
        if (typeof total !== 'undefined' && total >= 0){
            this.total = total;
        }
    }

    // force eta calculation update (long running processes)
    updateETA(){
        // add new value; recalculate eta
        this.eta.update(Date.now(), this.value, this.total);
    }
};

// utility to merge defaults
function mergeOption(v, defaultValue){
    if (typeof v === 'undefined' || v === null){
        return defaultValue;
    }else {
        return v;
    }
}

var options = {
    // set global options
    parse: function parse(rawOptions, preset){

        // options storage
        const options = {};

        // merge preset
        const opt = Object.assign({}, preset, rawOptions);

        // the max update rate in fps (redraw will only triggered on value change)
        options.throttleTime = 1000 / (mergeOption(opt.fps, 10));

        // the output stream to write on
        options.stream = mergeOption(opt.stream, process.stderr);

        // external terminal provided ?
        options.terminal = mergeOption(opt.terminal, null);

        // clear on finish ?
        options.clearOnComplete = mergeOption(opt.clearOnComplete, false);

        // stop on finish ?
        options.stopOnComplete = mergeOption(opt.stopOnComplete, false);

        // size of the progressbar in chars
        options.barsize = mergeOption(opt.barsize, 40);

        // position of the progress bar - 'left' (default), 'right' or 'center'
        options.align = mergeOption(opt.align, 'left');

        // hide the cursor ?
        options.hideCursor = mergeOption(opt.hideCursor, false);

        // disable linewrapping ?
        options.linewrap = mergeOption(opt.linewrap, false);

        // pre-render bar strings (performance)
        options.barCompleteString = (new Array(options.barsize + 1 ).join(opt.barCompleteChar || '='));
        options.barIncompleteString = (new Array(options.barsize + 1 ).join(opt.barIncompleteChar || '-'));

        // glue sequence (control chars) between bar elements ?
        options.barGlue = mergeOption(opt.barGlue, '');

        // the bar format
        options.format = mergeOption(opt.format, 'progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}');

        // external time-format provided ?
        options.formatTime = mergeOption(opt.formatTime, null);

        // external value-format provided ?
        options.formatValue = mergeOption(opt.formatValue, null);

        // external bar-format provided ?
        options.formatBar = mergeOption(opt.formatBar, null);

        // the number of results to average ETA over
        options.etaBufferLength = mergeOption(opt.etaBuffer, 10);

        // automatic eta updates based on fps
        options.etaAsynchronousUpdate = mergeOption(opt.etaAsynchronousUpdate, false);

        // progress calculation relative to start value ? default start at 0
        options.progressCalculationRelative = mergeOption(opt.progressCalculationRelative, false);

        // allow synchronous updates ?
        options.synchronousUpdate = mergeOption(opt.synchronousUpdate, true);

        // notty mode
        options.noTTYOutput = mergeOption(opt.noTTYOutput, false);

        // schedule - 2s
        options.notTTYSchedule = mergeOption(opt.notTTYSchedule, 2000);
        
        // emptyOnZero - false
        options.emptyOnZero = mergeOption(opt.emptyOnZero, false);

        // force bar redraw even if progress did not change
        options.forceRedraw = mergeOption(opt.forceRedraw, false);

        // automated padding to fixed width ?
        options.autopadding = mergeOption(opt.autopadding, false);

        // autopadding character - empty in case autopadding is disabled
        options.autopaddingChar = options.autopadding ? mergeOption(opt.autopaddingChar, '   ') : '';

        // stop bar on SIGINT/SIGTERM to restore cursor settings ?
        options.gracefulExit = mergeOption(opt.gracefulExit, false);

        return options;
    }
};

const _GenericBar = genericBar;
const _options$1 = options;

// Progress-Bar constructor
var singleBar = class SingleBar extends _GenericBar{

    constructor(options, preset){
        super(_options$1.parse(options, preset));

        // the update timer
        this.timer = null;

        // disable synchronous updates in notty mode
        if (this.options.noTTYOutput && this.terminal.isTTY() === false){
            this.options.synchronousUpdate = false;
        }

        // update interval
        this.schedulingRate = (this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule);

        // callback used for gracefulExit
        this.sigintCallback = null;
    }

    // internal render function
    render(){
        // stop timer
        if (this.timer){
            clearTimeout(this.timer);
            this.timer = null;
        }

        // run internal rendering
        super.render();

        // add new line in notty mode!
        if (this.options.noTTYOutput && this.terminal.isTTY() === false){
            this.terminal.newline();
        }

        // next update
        this.timer = setTimeout(this.render.bind(this), this.schedulingRate);
    }

    update(current, payload){
        // timer inactive ?
        if (!this.timer) {
            return;
        }

        super.update(current, payload);

        // trigger synchronous update ?
        // check for throttle time 
        if (this.options.synchronousUpdate && (this.lastRedraw + this.options.throttleTime*2) < Date.now()){
            // force update
            this.render();
        }
    }

    // start the progress bar
    start(total, startValue, payload){
        // progress updates are only visible in TTY mode!
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false){
            return;
        }

        // add handler to restore cursor settings (stop the bar) on SIGINT/SIGTERM ?
        if (this.sigintCallback === null && this.options.gracefulExit){
            this.sigintCallback = this.stop.bind(this);
            process.once('SIGINT', this.sigintCallback);
            process.once('SIGTERM', this.sigintCallback);
        }

        // save current cursor settings
        this.terminal.cursorSave();

        // hide the cursor ?
        if (this.options.hideCursor === true){
            this.terminal.cursor(false);
        }

        // disable line wrapping ?
        if (this.options.linewrap === false){
            this.terminal.lineWrapping(false);
        }

        // initialize bar
        super.start(total, startValue, payload);

        // redraw on start!
        this.render();
    }

    // stop the bar
    stop(){
        // timer inactive ?
        if (!this.timer) {
            return;
        }
        
        // remove sigint listener
        if (this.sigintCallback){
            process.removeListener('SIGINT', this.sigintCallback);
            process.removeListener('SIGTERM', this.sigintCallback);
            this.sigintCallback = null;
        }

        // trigger final rendering
        this.render();

        // restore state
        super.stop();

        // stop timer
        clearTimeout(this.timer);
        this.timer = null;

        // cursor hidden ?
        if (this.options.hideCursor === true){
            this.terminal.cursor(true);
        }

        // re-enable line wrapping ?
        if (this.options.linewrap === false){
            this.terminal.lineWrapping(true);
        }

        // restore cursor on complete (position + settings)
        this.terminal.cursorRestore();

        // clear line on complete ?
        if (this.options.clearOnComplete){
            this.terminal.cursorTo(0, null);
            this.terminal.clearLine();
        }else {
            // new line on complete
            this.terminal.newline();
        }
    }
};

const _Terminal = terminal;
const _BarElement = genericBar;
const _options = options;
const _EventEmitter = require$$3;

// Progress-Bar constructor
var multiBar = class MultiBar extends _EventEmitter{

    constructor(options, preset){
        super();

        // list of bars
        this.bars = [];

        // parse+store options
        this.options = _options.parse(options, preset);

        // disable synchronous updates
        this.options.synchronousUpdate = false;

        // store terminal instance
        this.terminal = (this.options.terminal) ? this.options.terminal : new _Terminal(this.options.stream);

        // the update timer
        this.timer = null;

        // progress bar active ?
        this.isActive = false;

        // update interval
        this.schedulingRate = (this.terminal.isTTY() ? this.options.throttleTime : this.options.notTTYSchedule);

        // logging output buffer
        this.loggingBuffer = [];

        // callback used for gracefulExit
        this.sigintCallback = null;
    }

    // add a new bar to the stack
    create(total, startValue, payload, barOptions={}){
        // create new bar element
        const bar = new _BarElement(Object.assign({}, this.options, barOptions));

        // store bar
        this.bars.push(bar);

        // progress updates are only visible in TTY mode!
        if (this.options.noTTYOutput === false && this.terminal.isTTY() === false){
            return bar;
        }

        // add handler to restore cursor settings (stop the bar) on SIGINT/SIGTERM ?
        if (this.sigintCallback === null && this.options.gracefulExit){
            this.sigintCallback = this.stop.bind(this);
            process.once('SIGINT', this.sigintCallback);
            process.once('SIGTERM', this.sigintCallback);
        }
        
        // multiprogress already active ?
        if (!this.isActive){
            // hide the cursor ?
            if (this.options.hideCursor === true){
                this.terminal.cursor(false);
            }

            // disable line wrapping ?
            if (this.options.linewrap === false){
                this.terminal.lineWrapping(false);
            }
    
            // initialize update timer
            this.timer = setTimeout(this.update.bind(this), this.schedulingRate);
        }

        // set flag
        this.isActive = true;

        // start progress bar
        bar.start(total, startValue, payload);

        // trigger event
        this.emit('start');

        // return new instance
        return bar;
    }

    // remove a bar from the stack
    remove(bar){
        // find element
        const index = this.bars.indexOf(bar);

        // element found ?
        if (index < 0){
            return false;
        }

        // remove element
        this.bars.splice(index, 1);

        // force update
        this.update();

        // clear bottom
        this.terminal.newline();
        this.terminal.clearBottom();

        return true;
    }

    // internal update routine
    update(){
        // stop timer
        if (this.timer){
            clearTimeout(this.timer);
            this.timer = null;
        }

        // trigger event
        this.emit('update-pre');
        
        // reset cursor
        this.terminal.cursorRelativeReset();

        // trigger event
        this.emit('redraw-pre');

        // content within logging buffer ?
        if (this.loggingBuffer.length > 0){
            this.terminal.clearLine();

            // flush logging buffer and write content to terminal
            while (this.loggingBuffer.length > 0){
                this.terminal.write(this.loggingBuffer.shift(), true);
            }
        }

        // update each bar
        for (let i=0; i< this.bars.length; i++){
            // add new line ?
            if (i > 0){
                this.terminal.newline();
            }

            // render
            this.bars[i].render();
        }

        // trigger event
        this.emit('redraw-post');

        // add new line in notty mode!
        if (this.options.noTTYOutput && this.terminal.isTTY() === false){
            this.terminal.newline();
            this.terminal.newline();
        }

        // next update
        this.timer = setTimeout(this.update.bind(this), this.schedulingRate);

        // trigger event
        this.emit('update-post');

        // stop if stopOnComplete and all bars stopped
        if (this.options.stopOnComplete && !this.bars.find(bar => bar.isActive)) {
            this.stop();
        }
    }

    stop(){

        // stop timer
        clearTimeout(this.timer);
        this.timer = null;

        // remove sigint listener
        if (this.sigintCallback){
            process.removeListener('SIGINT', this.sigintCallback);
            process.removeListener('SIGTERM', this.sigintCallback);
            this.sigintCallback = null;
        }

        // set flag
        this.isActive = false;

        // cursor hidden ?
        if (this.options.hideCursor === true){
            this.terminal.cursor(true);
        }

        // re-enable line wrpaping ?
        if (this.options.linewrap === false){
            this.terminal.lineWrapping(true);
        }

        // reset cursor
        this.terminal.cursorRelativeReset();

        // trigger event
        this.emit('stop-pre-clear');

        // clear line on complete ?
        if (this.options.clearOnComplete){
            // clear all bars
            this.terminal.clearBottom();
            
        // or show final progress ?
        }else {
            // update each bar
            for (let i=0; i< this.bars.length; i++){
                // add new line ?
                if (i > 0){
                    this.terminal.newline();
                }

                // trigger final rendering
                this.bars[i].render();

                // stop
                this.bars[i].stop();
            }

            // new line on complete
            this.terminal.newline();
        }

        // trigger event
        this.emit('stop');
    }

    log(s){
        // push content into logging buffer
        this.loggingBuffer.push(s);
    }
};

// cli-progress legacy style as of 1.x
var legacy = {
    format: 'progress [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}',
    barCompleteChar: '=',
    barIncompleteChar: '-'
};

// cli-progress legacy style as of 1.x
var shadesClassic = {
    format: ' {bar} {percentage}% | ETA: {eta}s | {value}/{total}',
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591'
};

// cli-progress legacy style as of 1.x
var shadesGrey = {
    format: ' \u001b[90m{bar}\u001b[0m {percentage}% | ETA: {eta}s | {value}/{total}',
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591'
};

var rect = {
    format: ' {bar}\u25A0 {percentage}% | ETA: {eta}s | {value}/{total}',
    barCompleteChar: '\u25A0',
    barIncompleteChar: ' '
};

const _legacy = legacy;
const _shades_classic = shadesClassic;
const _shades_grey = shadesGrey;
const _rect = rect;

var presets = {
    legacy: _legacy,
    shades_classic: _shades_classic,
    shades_grey: _shades_grey,
    rect: _rect
};

const _SingleBar = singleBar;
const _MultiBar = multiBar;
const _Presets = presets;
const _Formatter = formatter;
const _defaultFormatValue = formatValue;
const _defaultFormatBar = formatBar;
const _defaultFormatTime = formatTime;

// sub-module access
var cliProgress = {
    Bar: _SingleBar,
    SingleBar: _SingleBar,
    MultiBar: _MultiBar,
    Presets: _Presets,
    Format: {
        Formatter: _Formatter,
        BarFormat: _defaultFormatBar,
        ValueFormat: _defaultFormatValue,
        TimeFormat: _defaultFormatTime
    }
};

var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

var cjs = deepmerge_1;

const debug = _debug("taze:config");
const LOGLEVELS = ["debug", "info", "warn", "error", "silent"];
function normalizeConfig(options) {
  options.ignorePaths = toArray(options.ignorePaths);
  options.exclude = toArray(options.exclude);
  options.include = toArray(options.include);
  if (options.silent)
    options.loglevel = "silent";
  return options;
}
async function resolveConfig(options) {
  options = normalizeConfig(options);
  const loader = createConfigLoader({
    sources: [
      {
        files: [
          "taze.config"
        ]
      },
      {
        files: [
          ".tazerc"
        ],
        extensions: ["json", ""]
      }
    ],
    cwd: options.cwd || process.cwd(),
    merge: false
  });
  const config = await loader.load();
  if (!config.sources.length)
    return options;
  debug(`config file found ${config.sources[0]}`);
  const configOptions = normalizeConfig(config.config);
  return cjs(configOptions, options);
}

const FIG_CHECK = picocolors.exports.green("\u25C9");
const FIG_UNCHECK = picocolors.exports.gray("\u25CC");
const FIG_POINTER = picocolors.exports.cyan("\u276F ");
const FIG_NO_POINTER = "  ";
const FIG_BLOCK = picocolors.exports.bold(picocolors.exports.dim(picocolors.exports.gray("\u2503")));
const ansiRegex = ({ onlyFirst = false } = {}) => {
  const pattern = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern, onlyFirst ? void 0 : "g");
};
const stripAnsi = (str) => typeof str === "string" ? str.replace(ansiRegex(), "") : str;
function visualLength(str) {
  if (str === "")
    return 0;
  str = stripAnsi(str);
  let width = 0;
  for (let i = 0; i < str.length; i++) {
    const code = str.codePointAt(i);
    if (!code)
      continue;
    if (code <= 31 || code >= 127 && code <= 159)
      continue;
    if (code >= 768 && code <= 879)
      continue;
    if (code > 65535)
      i++;
    width += 1;
  }
  return width;
}
function visualPadStart(str, pad, char = " ") {
  return str.padStart(pad - visualLength(str) + str.length, char);
}
function visualPadEnd(str, pad, char = " ") {
  return str.padEnd(pad - visualLength(str) + str.length, char);
}
function formatTable(lines, align, spaces = "  ") {
  const maxLen = [];
  lines.forEach((line) => {
    line.forEach((char, i) => {
      const len = visualLength(char);
      if (!maxLen[i] || maxLen[i] < len)
        maxLen[i] = len;
    });
  });
  return lines.map((line) => line.map((chars, i) => {
    const pad = align[i] === "R" ? visualPadStart : visualPadEnd;
    return pad(chars, maxLen[i]);
  }).join(spaces));
}
function colorizeVersionDiff(from, to, hightlightRange = true) {
  let leadingWildcard = "";
  let fromLeadingWildcard = "";
  if (/^[~^]/.test(to)) {
    leadingWildcard = to[0];
    to = to.slice(1);
  }
  if (/^[~^]/.test(from)) {
    fromLeadingWildcard = from[0];
    from = from.slice(1);
  }
  const partsToColor = to.split(".");
  const partsToCompare = from.split(".");
  let i = partsToColor.findIndex((part, i2) => part !== partsToCompare[i2]);
  i = i >= 0 ? i : partsToColor.length;
  const color = i === 0 || partsToColor[0] === "0" ? "red" : i === 1 ? "cyan" : "green";
  const middot = i > 0 && i < partsToColor.length ? "." : "";
  const leadingColor = leadingWildcard === fromLeadingWildcard || !hightlightRange ? "gray" : "yellow";
  return picocolors.exports[leadingColor](leadingWildcard) + partsToColor.slice(0, i).join(".") + middot + picocolors.exports[color](partsToColor.slice(i).join(".")).trim();
}

function shouldLog(level, messageLevel) {
  return LOGLEVELS.indexOf(level) <= LOGLEVELS.indexOf(messageLevel);
}
class TableLogger {
  constructor(options = {}) {
    this.rows = [];
    const {
      columns = 3,
      pending = 2,
      align = "",
      loglevel = "error"
    } = options;
    this.options = {
      columns,
      pending,
      align,
      loglevel
    };
  }
  row(...args) {
    this.rows.push(args);
  }
  log(string = "") {
    this.rows.push(string);
  }
  error(string = "") {
    if (shouldLog(this.options.loglevel, "error"))
      this.rows.push(string);
  }
  warn(string = "") {
    if (shouldLog(this.options.loglevel, "warn"))
      this.rows.push(string);
  }
  debug(string = "") {
    if (shouldLog(this.options.loglevel, "debug"))
      this.rows.push(string);
  }
  output() {
    if (this.options.loglevel === "silent")
      return;
    const { columns, align, pending } = this.options;
    const columnsWidth = new Array(columns).fill(0);
    this.rows.forEach((line) => {
      if (typeof line === "string")
        return;
      for (let i = 0; i < columns; i++)
        columnsWidth[i] = Math.max(columnsWidth[i], visualLength(line[i] || ""));
    });
    this.rows.forEach((line) => {
      if (typeof line === "string") {
        process.stdout.write(`${line}
`);
        return;
      }
      for (let i = 0; i < columns; i++) {
        const pad = align[i] === "R" ? visualPadStart : visualPadEnd;
        const part = line[i] || "";
        process.stdout.write(pad(part, columnsWidth[i] + pending));
      }
      process.stdout.write("\n");
    });
    this.rows = [];
  }
}
function createMultiProgresBar() {
  return new cliProgress.MultiBar({
    clearOnComplete: true,
    hideCursor: true,
    format: `{type} {bar} {value}/{total} ${picocolors.exports.gray("{name}")}`,
    linewrap: false,
    barsize: 40
  }, cliProgress.Presets.shades_grey);
}
function wrapJoin(strs, delimiter, width) {
  const lines = [];
  let line = "";
  for (let i = 0; i < strs.length; i++) {
    const str = strs[i];
    if (line && visualLength(line + str) > width) {
      lines.push(line);
      line = "";
    }
    line += str;
    if (i < strs.length - 1)
      line += delimiter;
  }
  lines.push(line);
  return lines;
}

function notNullish(v) {
  return v != null;
}
function createControlledPromise() {
  let resolve, reject;
  const promise = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  promise.resolve = resolve;
  promise.reject = reject;
  return promise;
}

const msPerMinute = 60 * 1e3;
const msPerHour = msPerMinute * 60;
const msPerDay = msPerHour * 24;
const msPerMonth = msPerDay * 30;
const msPerYear = msPerDay * 365;
function toDate(date) {
  return +new Date(date);
}
function timeDifference(from, to = +new Date()) {
  if (!from)
    return "";
  if (typeof from === "string")
    from = toDate(from);
  const elapsed = to - from;
  if (elapsed < msPerDay)
    return picocolors.exports.gray("\u2A7D1d");
  else if (elapsed < msPerMonth)
    return picocolors.exports.green(`~${Math.round(elapsed / msPerDay)}d`);
  else if (elapsed < msPerYear)
    return picocolors.exports.yellow(`~${Math.round(elapsed / msPerMonth)}mo`);
  else
    return picocolors.exports.red(`~${+(elapsed / msPerYear).toFixed(1)}y`);
}

function parseSortOption(option) {
  return option.split("-");
}
function sortDepChanges(changes, option) {
  const [sortKey, order = "asc"] = parseSortOption(option);
  const sorted = changes.concat().sort((a, b) => {
    if (sortKey === "time") {
      if (a.targetVersionTime && b.targetVersionTime) {
        const at = toDate(a.targetVersionTime);
        const bt = toDate(b.targetVersionTime);
        return bt - at;
      }
    } else if (sortKey === "name") {
      return a.name.localeCompare(b.name);
    } else if (sortKey === "diff") {
      return DiffMap[a.diff || ""] - DiffMap[b.diff || ""];
    }
    return 0;
  });
  return order === "desc" ? sorted.reverse() : sorted;
}

function renderChange(change, interactive) {
  const update = change.update && (!interactive || change.interactiveChecked);
  const isSelected = interactive && interactive.isSelected(change);
  const pre = interactive ? [
    isSelected ? FIG_POINTER : FIG_NO_POINTER,
    change.interactiveChecked ? FIG_CHECK : FIG_UNCHECK
  ].join("") : " ";
  return [
    `${pre} ${update ? change.name : picocolors.exports.gray(change.name)}`,
    picocolors.exports.gray(DependenciesTypeShortMap[change.source]),
    timeDifference(change.currentVersionTime),
    picocolors.exports.gray(change.currentVersion),
    update ? picocolors.exports.dim(picocolors.exports.gray("\u2192")) : "",
    update ? colorizeVersionDiff(change.currentVersion, change.targetVersion) : picocolors.exports.gray(picocolors.exports.strikethrough(change.targetVersion)),
    update ? timeDifference(change.targetVersionTime) : "",
    change.latestVersionAvailable && semver.minVersion(change.targetVersion).toString() !== change.latestVersionAvailable ? picocolors.exports.dim(picocolors.exports.magenta(`(${change.latestVersionAvailable} available)`)) : ""
  ];
}
function renderChanges(pkg, options, interactive) {
  const { resolved, relative: filepath } = pkg;
  const lines = [];
  const errLines = [];
  let changes = options.all ? resolved : resolved.filter((i) => i.update);
  const {
    sort = "diff-asc"
  } = options;
  if (changes.length) {
    const diffCounts = {};
    changes.filter((i) => !interactive || i.interactiveChecked).forEach(({ diff }) => {
      if (!diff)
        return;
      if (!diffCounts[diff])
        diffCounts[diff] = 0;
      diffCounts[diff] += 1;
    });
    const diffEntries = Object.keys(diffCounts).length ? Object.entries(diffCounts).map(([key, value]) => `${picocolors.exports.yellow(value)} ${key}`).join(", ") : picocolors.exports.dim("no change");
    lines.push(
      `${picocolors.exports.cyan(pkg.name ?? "\u203A")} ${picocolors.exports.dim("-")} ${diffEntries}`,
      ""
    );
    changes = sortDepChanges(changes, sort);
    lines.push(...formatTable(
      changes.map((c2) => renderChange(c2, interactive)),
      "LLRRRRRL"
    ));
    lines.push("");
  } else if (options.all) {
    lines.push(`${picocolors.exports.cyan(pkg.name)} ${picocolors.exports.dim(filepath)}`);
    lines.push();
    lines.push(picocolors.exports.gray("  \u2713 up to date"));
  }
  const errors = pkg.resolved.filter((i) => i.resolveError != null);
  if (errors.length) {
    lines.push();
    for (const dep of errors)
      errLines.push(...renderResolveError(dep));
    lines.push();
  }
  return {
    lines,
    errLines
  };
}
function renderResolveError(dep) {
  const lines = [];
  if (dep.resolveError == null)
    return lines;
  if (dep.resolveError === "404") {
    lines.push(picocolors.exports.red(`> ${picocolors.exports.underline(dep.name)} not found`));
  } else if (dep.resolveError === "invalid_range") ; else {
    lines.push(picocolors.exports.red(`> ${picocolors.exports.underline(dep.name)} unknown error`));
    lines.push(picocolors.exports.red(dep.resolveError.toString()));
  }
  return lines;
}
function renderPackages(resolvePkgs, options) {
  const lines = [""];
  const errLines = [];
  resolvePkgs.forEach((pkg) => {
    const result = renderChanges(pkg, options);
    lines.push(...result.lines);
    errLines.push(...result.errLines);
  });
  return { lines, errLines };
}

async function promptInteractive(pkgs, options) {
  pkgs.forEach((i) => {
    i.interactiveChecked = true;
    i.resolved.forEach((i2) => {
      i2.interactiveChecked = i2.update;
      if (i2.latestVersionAvailable && !i2.update) {
        i2.interactiveChecked = false;
        i2.update = true;
        updateTargetVersion(i2, i2.latestVersionAvailable);
      }
    });
  });
  if (!pkgs.some((i) => i.resolved.some((i2) => i2.update)))
    return [];
  const promise = createControlledPromise();
  const listRenderer = createListRenderer();
  let renderer = listRenderer;
  registerInput();
  renderer.render();
  return await promise.finally(() => {
    renderer = {
      render: () => {
      },
      onKey: () => false
    };
  });
  function createListRenderer() {
    const deps = pkgs.flatMap((i) => i.resolved.filter((i2) => i2.update));
    let index = 0;
    const ctx = {
      isSelected(dep) {
        return dep === deps[index];
      }
    };
    return {
      render() {
        const Y = (v) => picocolors.exports.bold(picocolors.exports.green(v));
        console.clear();
        console.log(`${FIG_BLOCK} ${picocolors.exports.gray(`${Y("\u2191\u2193")} to select, ${Y("space")} to toggle, ${Y("\u2192")} to change version`)}`);
        console.log(`${FIG_BLOCK} ${picocolors.exports.gray(`${Y("enter")} to confirm, ${Y("esc")} to cancel`)}`);
        console.log();
        const lines = [];
        pkgs.forEach((pkg) => {
          lines.push(...renderChanges(pkg, options, ctx).lines);
        });
        console.log(lines.join("\n"));
      },
      onKey(key) {
        if (key.name === "escape") {
          process.exit();
        } else if (key.name === "enter" || key.name === "return") {
          console.clear();
          pkgs.forEach((i) => {
            i.resolved.forEach((i2) => {
              i2.update = !!i2.interactiveChecked;
            });
          });
          promise.resolve(pkgs);
        } else if (key.name === "up") {
          index = (index - 1 + deps.length) % deps.length;
          return true;
        } else if (key.name === "down") {
          index = (index + 1) % deps.length;
          return true;
        } else if (key.name === "space") {
          deps[index].interactiveChecked = !deps[index].interactiveChecked;
          return true;
        } else if (key.name === "right") {
          renderer = createVersionSelectRender(deps[index]);
          return true;
        }
      }
    };
  }
  function createVersionSelectRender(dep) {
    const versions = Object.entries({
      minor: getVersionOfRange(dep, "minor"),
      patch: getVersionOfRange(dep, "patch"),
      ...dep.pkgData.tags
    }).map(([name, version]) => {
      if (!version)
        return void 0;
      const targetVersion = getPrefixedVersion(dep.currentVersion, version);
      if (!targetVersion || targetVersion === dep.currentVersion)
        return void 0;
      return {
        name,
        version,
        time: dep.pkgData.time?.[version],
        targetVersion: getPrefixedVersion(dep.currentVersion, version)
      };
    }).filter(notNullish);
    let index = 0;
    return {
      render() {
        console.clear();
        console.log(`${FIG_BLOCK} ${picocolors.exports.gray(`Select a version for ${picocolors.exports.green(picocolors.exports.bold(dep.name))}${picocolors.exports.gray(` (current ${dep.currentVersion})`)}`)}`);
        console.log();
        console.log(
          formatTable(versions.map((v, idx) => {
            return [
              (index === idx ? FIG_POINTER : FIG_NO_POINTER) + (index === idx ? v.name : picocolors.exports.gray(v.name)),
              timeDifference(dep.currentVersionTime),
              picocolors.exports.gray(dep.currentVersion),
              picocolors.exports.dim(picocolors.exports.gray("\u2192")),
              colorizeVersionDiff(dep.currentVersion, v.targetVersion),
              timeDifference(v.time)
            ];
          }), "LLLL").join("\n")
        );
      },
      onKey(key) {
        if (key.name === "escape") {
          renderer = listRenderer;
          return true;
        } else if (key.name === "up") {
          index = (index - 1 + versions.length) % versions.length;
          return true;
        } else if (key.name === "down") {
          index = (index + 1) % versions.length;
          return true;
        } else if (key.name === "enter" || key.name === "return" || key.name === "left" || key.name === "right") {
          updateTargetVersion(dep, versions[index].version);
          renderer = listRenderer;
          return true;
        }
      }
    };
  }
  function registerInput() {
    process.stdin.resume();
    process.stdin.setEncoding("utf8");
    require$$0$1.emitKeypressEvents(process.stdin);
    if (process.stdin.isTTY)
      process.stdin.setRawMode(true);
    process.stdin.on("keypress", (str, key) => {
      if (key.ctrl && key.name === "c")
        process.exit();
      const result = renderer.onKey(key);
      if (result && typeof result !== "boolean")
        renderer = result;
      if (result)
        renderer.render();
    });
  }
}

async function check(options) {
  const bars = options.loglevel === "silent" ? null : createMultiProgresBar();
  let packagesBar;
  const depBar = bars?.create(1, 0);
  let resolvePkgs = [];
  await CheckPackages(options, {
    afterPackagesLoaded(pkgs) {
      packagesBar = options.recursive && pkgs.length ? bars?.create(pkgs.length, 0, { type: picocolors.exports.cyan("pkg"), name: picocolors.exports.cyan(pkgs[0].name) }) : void 0;
    },
    beforePackageStart(pkg) {
      packagesBar?.increment(0, { name: picocolors.exports.cyan(pkg.name) });
      depBar?.start(pkg.deps.length, 0, { type: picocolors.exports.green("dep") });
    },
    beforePackageWrite() {
      return false;
    },
    afterPackageEnd(pkg) {
      packagesBar?.increment(1);
      depBar?.stop();
      resolvePkgs.push(pkg);
    },
    onDependencyResolved(pkgName, name, progress) {
      depBar?.update(progress, { name });
    }
  });
  bars?.stop();
  if (options.interactive)
    resolvePkgs = await promptInteractive(resolvePkgs, options);
  const hasChanges = resolvePkgs.length && resolvePkgs.some((i) => i.resolved.some((j) => j.update));
  if (!hasChanges)
    return console.log(picocolors.exports.green("dependencies are already up-to-date"));
  const { lines, errLines } = renderPackages(resolvePkgs, options);
  console.log(lines.join("\n"));
  if (!options.all) {
    const counter = resolvePkgs.reduce((counter2, pkg) => {
      for (let i = 0; i < pkg.resolved.length; i++) {
        if (pkg.resolved[i].update)
          return ++counter2;
      }
      return counter2;
    }, 0);
    const last = resolvePkgs.length - counter;
    if (last === 1)
      console.log(picocolors.exports.green("dependencies are already up-to-date in one package\n"));
    else if (last > 0)
      console.log(picocolors.exports.green(`dependencies are already up-to-date in ${last} packages
`));
  }
  if (errLines.length) {
    console.error(picocolors.exports.inverse(picocolors.exports.red(picocolors.exports.bold(" ERROR "))));
    console.error();
    console.error(errLines.join("\n"));
    console.error();
  }
  if (options.interactive && !options.write) {
    options.write = await prompts([
      {
        name: "write",
        type: "confirm",
        initial: true,
        message: picocolors.exports.green("write to package.json")
      }
    ]).then((r) => r.write);
  }
  if (options.write) {
    for (const pkg of resolvePkgs)
      await writePackage(pkg, options);
  }
  if (!options.write) {
    console.log();
    if (options.mode === "default")
      console.log(`Run ${picocolors.exports.cyan("taze major")} to check major updates`);
    if (hasChanges)
      console.log(`Add ${picocolors.exports.green("-w")} to write package.json`);
    console.log();
  } else if (hasChanges) {
    if (!options.install && !options.update && !options.interactive) {
      console.log(
        picocolors.exports.yellow(`\u2139 changes wrote to package.json, run ${picocolors.exports.cyan("npm i")} to install updates.`)
      );
    }
    if (options.install || options.update || options.interactive)
      console.log(picocolors.exports.yellow("\u2139 changes wrote to package.json"));
    if (options.interactive && !options.install) {
      options.install = await prompts([
        {
          name: "install",
          type: "confirm",
          initial: true,
          message: picocolors.exports.green("install now")
        }
      ]).then((r) => r.install);
    }
    if (options.install) {
      console.log(picocolors.exports.magenta("installing..."));
      console.log();
      await run(parseNi, []);
    }
    if (options.update) {
      console.log(picocolors.exports.magenta("updating..."));
      console.log();
      await run(parseNu, options.recursive ? ["-r"] : []);
    }
  }
}

async function CheckUsages(options, callbacks = {}) {
  const packages = await loadPackages(options);
  const names = {};
  for (const pkg of packages) {
    for (const dep of pkg.deps) {
      if (!names[dep.name])
        names[dep.name] = {};
      if (!names[dep.name][dep.currentVersion])
        names[dep.name][dep.currentVersion] = [];
      names[dep.name][dep.currentVersion].push(pkg);
    }
  }
  const usages = Object.entries(names).filter((i) => Object.keys(i[1]).length > 1).sort((a, b) => Object.keys(b[1]).length - Object.keys(a[1]).length).map(([name, versionMap]) => ({ name, versionMap }));
  callbacks.onLoaded?.(usages);
  let progress = 0;
  const total = usages.length;
  const resolveUsages = await Promise.all(
    usages.map(async ({ name, versionMap }) => {
      const { tags } = await getPackageData(name);
      progress += 1;
      callbacks.onDependencyResolved?.(null, name, progress, total);
      return { name, versionMap, latest: tags.latest || "" };
    })
  );
  return resolveUsages;
}

async function usage(options) {
  const bars = createMultiProgresBar();
  const logger = new TableLogger({
    columns: 5,
    align: "LRRRR",
    loglevel: options.loglevel
  });
  logger.log();
  let depBar;
  const resolveUsages = await CheckUsages(options, {
    onLoaded(usages) {
      depBar = bars.create(usages.length, 0, { type: picocolors.exports.green("deps") });
    },
    onDependencyResolved(_, name) {
      depBar?.increment(1, { name });
    }
  });
  bars.stop();
  for (const { name, versionMap, latest } of resolveUsages) {
    const versions = Object.keys(versionMap).sort();
    const packagesCount = Object.values(versionMap).flatMap((i) => i).length;
    if (versions.length > 1) {
      const color = versions.length >= 5 ? "magenta" : versions.length >= 3 ? "red" : "yellow";
      if (options.detail) {
        logger.log();
        logger.row(
          `${picocolors.exports.green(name)} ${picocolors.exports.gray(`\xB7 ${versions.length} versions \xB7 latest: ${picocolors.exports.blue(latest)}`)}`
        );
        const pad = Math.max(8, ...Object.keys(versionMap).map((i) => i.length)) + 2;
        for (const [version, pkgs] of Object.entries(versionMap)) {
          const lines = wrapJoin(pkgs.map((p) => p.name), picocolors.exports.gray(", "), 80);
          lines.forEach((line, i) => {
            if (i === 0)
              logger.log(`${visualPadStart(picocolors.exports.gray(colorizeVersionDiff(latest || version, version, false)), pad, " ")}  ${line}`);
            else
              logger.log(`${" ".padStart(pad, " ")}  ${line}`);
          });
        }
      } else {
        logger.row(
          picocolors.exports.green(name),
          picocolors.exports.gray(`${picocolors.exports.cyan(packagesCount.toString())} in use / ${picocolors.exports[color](versions.length.toString())} versions`),
          versions.map((v) => picocolors.exports.gray(colorizeVersionDiff(latest || v, v, false))).join(picocolors.exports.gray(", ")),
          picocolors.exports.gray("\u2192"),
          latest
        );
      }
    }
  }
  logger.log();
  logger.output();
}

function commonOptions(args) {
  return args.option("cwd", {
    alias: "C",
    default: "",
    type: "string",
    describe: "specify the current working directory"
  }).option("loglevel", {
    default: "info",
    type: "string",
    describe: "log level",
    choices: LOGLEVELS
  }).option("silent", {
    alias: "s",
    default: false,
    type: "boolean",
    describe: "complete silent"
  }).option("recursive", {
    alias: "r",
    type: "boolean",
    describe: "recursively search for package.json in subdirectories"
  }).option("force", {
    alias: "f",
    type: "boolean",
    describe: "force fetching from server, bypass cache"
  }).option("sort", {
    type: "string",
    default: "diff-asc",
    choices: ["time-asc", "time-desc", "diff-asc", "diff-desc", "name-asc", "name-desc", "time", "diff", "name"],
    describe: "sort by most outdated absolute or relative to dependency"
  }).option("ignore-paths", {
    type: "string",
    describe: "ignore paths for search package.json"
  }).option("include", {
    alias: "n",
    type: "string",
    describe: "only included dependencies will be checked for updates"
  }).option("exclude", {
    alias: "x",
    type: "string",
    describe: "exclude dependencies to be checked, will override --include options"
  }).option("dev", {
    alias: "D",
    type: "boolean",
    describe: "update only for devDependencies",
    conflicts: ["prod"]
  }).option("prod", {
    alias: "P",
    type: "boolean",
    describe: "update only for dependencies",
    conflicts: ["dev"]
  });
}
yargs(hideBin(process.argv)).scriptName("taze").usage("$0 [args]").command(
  "usage",
  "List dependencies versions usage across packages",
  (args) => {
    return commonOptions(args).option("detail", {
      alias: "a",
      type: "boolean",
      default: false,
      describe: "show more info"
    }).help().demandOption("recursive", picocolors.exports.yellow("Please add -r to analysis usages"));
  },
  async (args) => usage(await resolveConfig({ ...args, recursive: true }))
).command(
  "* [mode]",
  "Keeps your deps fresh",
  (args) => {
    return commonOptions(args).positional("mode", {
      default: "default",
      type: "string",
      describe: 'the mode how version range resolves, can be "default", "major", "minor", "latest" or "newest"',
      choices: ["default", "major", "minor", "patch", "latest", "newest"]
    }).option("write", {
      alias: "w",
      default: false,
      type: "boolean",
      describe: "write to package.json"
    }).option("interactive", {
      alias: "I",
      default: false,
      type: "boolean",
      describe: "interactive mode"
    }).option("install", {
      alias: "i",
      default: false,
      type: "boolean",
      describe: "install directly after bumpping"
    }).option("update", {
      alias: "u",
      default: false,
      type: "boolean",
      describe: "update directly after bumpping"
    }).option("all", {
      alias: "a",
      default: false,
      type: "boolean",
      describe: "show all packages up to date info"
    }).help();
  },
  async (args) => {
    await check(await resolveConfig(args));
    process.exit();
  }
).showHelpOnFail(false).alias("h", "help").version("version", version).alias("v", "version").help().argv;
